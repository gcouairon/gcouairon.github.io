---
layout: post
title: Protein Design with Variational Auto Encoders
date:   2018-08-28 10:18:00
navigation: True
logo: 'assets/images/ghost.png'
cover: 'assets/images/prot_background.jpg'
tags: projects
subclass: 'post'
categories: 'phazcode'
---
<style>
body{font-size: 1.6rem;
line-height: 1.6em;}
</style>
<body for="html-export">
  <div class="mume markdown-preview   ">
  <h2 class="mume-header" id="abstract">Abstract</h2>

<p>Chains of amino-acids, i.e. proteins, are an essential building block of life that can carry out many useful functions for medical and industrial applications. The ability to extract information from protein sequences and to predict the effects of mutations is extremely valuable in many domains of biology and medicine. Designing proteins that are able to catalyze specific biochemical reactions is a major challenge tackled through computational methods as well as directed evolution, strategies that made huge improvements since the 1970 but are still faced with the intractability of exploring the gigantic space of all possible proteins.<br>
Recently, Generative Models such as GANs (Generative Adversarial Networks) and VAEs (Variational Auto Encoders) have been used successfully to model the distribution of images and to generate novel, realistic samples. Conditional Models have been used to generate samples with desired high-level features when annotated data is available, for instance <a href="https://blog.openai.com/glow/">here</a>.<br>
Here, we demonstrate the ability of such networks to generate novel proteins that have expected biochemical properties. In a first part, we use a computational model associated to a folding-related fitness metric to assess the quality of novel proteins generated by different models. We then build a Conditional VAE with an autoregressive decoder, inspired by the WaveNet architecture, that we call the ProtCNN. After training on a dataset of 70000 luciferase-like oxidoreductases, a set of proteins sharing a common biochemical activity, we show that the model is able to learn meaningful information such as amino-acid relatedness and can generate novel proteins when conditioning upon high level properties such as charge, molecular weight or solubility. We also introduce a fitness metric for the structure of the protein and show that our model is able to generate variants of a protein that have a consistent secondary structure. We believe that this type of model provides an intelligent way to explore the space of possible proteins and hope that the methods presented here will pave the way for new powerful tools to generate protein variants.</p>
<h4 class="mume-header" id="acknowledgements">Acknowledgements</h4>

<p>I want to thank <a href="https://research.pasteur.fr/en/member/david-bikard/">David Bikard</a>, my internship supervisor and head of the synthetic biology lab at <a href="https://www.pasteur.fr/fr">Institut Pasteur</a>, for his valuable support. Many thanks to Sebastien Baur for starting this project, and to <a href="http://jeromewongng.physics.ucsd.edu/">Jerome Wong Ng</a> and Alexander Hawkins Hooker for fruitful discussions.</p>
<p>The work presented here used the computational and storage services (TARS cluster) provided by the IT department at Institut Pasteur, Paris.</p>
<p>Code available <a href="https://gitlab.com/PhazCode/DeepProteinDesign">here</a>.</p>
<h2 class="mume-header" id="introduction">Introduction</h2>

<h3 class="mume-header" id="protein-design">Protein Design</h3>

<p>Proteins are large biomolecules, organized in long chains of amino acid residues, that perform many biological functions within organisms, among which DNA replication, metabolic reactions catalysis, converting various sources of energy (light, chemical gradients...), and transporting molecules from one place in the cell to another. Proteins also have a wide range of therapeutic, medical and industrial applications: industrial enzymes are used to produce food, biofuels, chemical and pharmaceutical products; recombinant proteins have medical applications involving vaccines and antibodies. In many of these applications, it is often desirable to modify properties of natural proteins to remove some disturbing side reaction or increase catalytic activity.</p>
<p>Protein design is the art of designing new molecules that have expected behaviors and biological functions, for instance ability to fold into specific structures and catalyze biochemical reactions. Directed evolution is a straightforward method to increase the fitness of a protein, that mimics the process of random mutation and natural selection <sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>. However this process is quite slow and only explores a fraction of all possible proteins, so rational protein design began in the 1970's.  Since then, it has made tremendous progress thanks to advances in molecular forcefields and bioinformatics, which paved the way for advanced computational protein design tools. In 2017, the global protein engineering market size was valued at about 1,000,000,000$, with an annual growth rate of about 16%.</p>
<p>Rational protein design can be performed from scratch (<em>de novo protein design</em>),  a field that made some progress recently<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup>. Most of the time however, protein design starts from existing proteins whose structure is already known <sup class="footnote-ref"><a href="#fn3" id="fnref3">[3]</a></sup>, and aims at identifying interesting mutations.</p>
<p>The properties of a protein highly depend on the spatial organization of its amino-acid chain. The amino acid residues of a protein interact with one another and with the external environment, causing the protein to fold into particular 3D structures in which it can fulfill its biological function. This process is called <strong>Protein Folding</strong>. Misfolded proteins are generally inactive, but might sometimes have modified or toxic functionality. For instance, many allergies are caused by proteins that acquire a non-native folding, because our immune system can produce antibodies for only certain protein structures.</p>
<img src="/projects/pasteur_images/Protein_folding.png">
<blockquote>
<p>Left: Amino-Acid Sequence, Right: Representation of folded protein</p>
</blockquote>
<p>Many chemical interactions are involved in the process of protein folding, including hydrophobicity, acidity, and hydrogen bonding effects. The relationship between the primary structure of a protein (its amino-acid sequence) and its native folding is only partly understood because of the complexity and the scale of atom-to-atom interactions. The problem of finding the 3D folding of a protein is extremely challenging due to severe computational limits on all-atoms simulations. Protein folding softwares, like <a href="http://raptorx.uchicago.edu/">RaptorX</a>, exploit amino acid interactions as well as homologies with proteins for which the 3D structure has been determined through physical methods (NMR Spectroscopy and X-ray crystallography). Computer-aided protein design can help identify interesting mutations, but the difficulty to predict protein fold and function make it hard to create functional variants of a protein.</p>
<p>This limitation associated with the gigantic space of the protein sequence space makes a systematic exploration of protein variants intractable: Indeed, the human  DNA directly encodes 20 different amino-acids, resulting in a protein space size of 20<sup>300</sup> for a fixed amino-acid chain length of 300, which is an average size for a protein.</p>
<p>A smart way to explore the protein space is therefore needed to generate functional variants that have interesting properties. Machine Learning methods are being reviewed for that purpose. A few recent studies have explored deep neural networks to model chemicals represented as SMILES strings in order to propose novel interesting molecules likely to have desired activities <sup class="footnote-ref"><a href="#fn4" id="fnref4">[4]</a></sup> <sup class="footnote-ref"><a href="#fn5" id="fnref5">[5]</a></sup> <sup class="footnote-ref"><a href="#fn6" id="fnref6">[6]</a></sup>. In a recent paper <sup class="footnote-ref"><a href="#fn7" id="fnref7">[7]</a></sup>, variants of the green fluorescent protein (GFP) are made using supervised learning : The fitness function (light emission property) is being learned by a neural network, and new variants are being generated by Monte Carlo Sampling, interpreting the output of the model as energies.</p>
<p>Here, we make use of deep generative models, which offer extremely promising tools for the exploration of low-dimensional manifolds in high-dimensional spaces.</p>
<h3 class="mume-header" id="variational-auto-encoders">Variational Auto Encoders</h3>

<p>In Machine Learning, Generative Models are statistical models that given on observable variable <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.07847em;">X</span></span></span></span>, are able to sample data from the distribution of <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.07847em;">X</span></span></span></span>.<br>
Auto Encoders are neural networks, composed of an encoder network, that encodes the protein into a low dimensional vector space called the latent space, and a decoder that reconstructs the protein from its latent space representation. The network is then trained end-to-end using backpropagation. This principle is called an information bottleneck, and it forces the network to encode only the most important features of a protein into the latent space, that will allow for a faithful reconstruction of the protein. The identity function is learned in a non-trivial way, forcing the latent space to represent high-level features about the data.</p>
<div class="mermaid">graph LR
A(Input Space)
B(Latent Space)
C(Output)
A -- Encoder --> B
B -- Decoder --> C
</div><p>To help the network learn meaningful information in the latent space and reduce overfitting, Variational Auto Encoders <sup class="footnote-ref"><a href="#fn8" id="fnref8">[8]</a></sup> <sup class="footnote-ref"><a href="#fn9" id="fnref9">[9]</a></sup> are used. In a VAE, the distribution of the encoded data in latent space is forced to follow a normal distribution via a KL-divergence loss term. As a result, most areas of the latent space can be decoded into valid samples, and it is possible to adjust the level of each feature independently by sampling the latent space.<br>
For instance, when trained on faces, the VAE learns features such as hair color, presence of glasses, shape of the head, that can be changed manually by modifying the encoded representation of an image <sup class="footnote-ref"><a href="#fn10" id="fnref10">[10]</a></sup> <sup class="footnote-ref"><a href="#fn11" id="fnref11">[11]</a></sup> <sup class="footnote-ref"><a href="#fn12" id="fnref12">[12]</a></sup>. Moreover, it is possible to perform arithmetic operations and interpolation on the encoded vectors, which produces vectors that can be decoded to novel samples.</p>
<h3 class="mume-header" id="metrics-for-proteins">Metrics for Proteins</h3>

<p>Since the distribution of the input dataset is generally unknown, it is difficult to assess the quality of samples coming out of generative models. Two natural techniques for this purpose are whether humans, or adversarial networks, can tell the difference between the real data and the generated data <sup class="footnote-ref"><a href="#fn13" id="fnref13">[13]</a></sup>.</p>
<p>When generating new molecules, specific metrics exist, such as the Fréchet ChemblNet Distance <sup class="footnote-ref"><a href="#fn14" id="fnref14">[14]</a></sup>. The authors claim that the FCD can detect if generated molecules have similar chemical and biological properties as real molecules, and are distant enough from one another.</p>
<p>In this work we are going to focus in particular on to what extent a protein sequence can be mutated without removing its biological function. We will therefore discuss fitness functions related to biological activity to assess functionality, along with distance functions between proteins to assess how different a variant is from the original protein.<br>
The former is much more complicated than the latter as physical measurements, or at least simulations are involved in the calculation of functionality, and such fitness metrics will be defined throughout this work. For the distance between proteins, it is often sufficient to use the alignment metric, which is the <a href="https://en.wikipedia.org/wiki/Edit_distance">edit distance</a> between the sequences of theses proteins (number of insertions, deletions, and mismatches needed to go from a sequence to the other). This metric is fairly satisfying as it reflects quite well the process of natural evolution. In this metric however, properties of amino-acids are not taken into account, and swapping amino-acids with similar properties is much more likely to have no impact on the protein's activity than swapping dissimilar amino-acids (positively charged and negatively charged for instance). This phenomenon is captured in the Blosum 62 Matrix <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>B</mi><mrow><mn>6</mn><mn>2</mn></mrow></msub></mrow><annotation encoding="application/x-tex">B_{62}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="base"><span class="mord"><span class="mord mathit" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05017em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">6</span><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span></span></span></span> <sup class="footnote-ref"><a href="#fn15" id="fnref15">[15]</a></sup>, which for two amino-acids <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">a</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.69444em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">b</span></span></span></span> indicates the level of interchangeability of those two amino-acids <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>B</mi><mrow><mn>6</mn><mn>2</mn></mrow></msub><mo>[</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">B_{62}[a, b]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mord"><span class="mord mathit" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05017em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">6</span><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span><span class="mopen">[</span><span class="mord mathit">a</span><span class="mpunct">,</span><span class="mord rule" style="margin-right:0.16666666666666666em;"></span><span class="mord mathit">b</span><span class="mclose">]</span></span></span></span>. This matrix is computed from alignments of sequences in families of proteins, and the '62' is a filter parameter in this computation.<br>
The higher the Blosum score of two amino-acids, the more easily one can be replaced by the other in a protein sequence without disturbing its structure. A high score for <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>B</mi><mrow><mn>6</mn><mn>2</mn></mrow></msub><mo>[</mo><mi>a</mi><mo separator="true">,</mo><mi>a</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">B_{62}[a, a]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mord"><span class="mord mathit" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05017em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">6</span><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span><span class="mopen">[</span><span class="mord mathit">a</span><span class="mpunct">,</span><span class="mord rule" style="margin-right:0.16666666666666666em;"></span><span class="mord mathit">a</span><span class="mclose">]</span></span></span></span> indicates that amino-acid <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">a</span></span></span></span> has specific properties and therefore is not easily swappable.</p>
<p>We define the <em>B62 distance</em>, which is the edit distance where the cost of a mismatch <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>↔</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">a \leftrightarrow b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.69444em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">a</span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mrel">↔</span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mord mathit">b</span></span></span></span> is <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>B</mi><mrow><mn>6</mn><mn>2</mn></mrow></msub><mo>[</mo><mi>a</mi><mo separator="true">,</mo><mi>a</mi><mo>]</mo><mo>−</mo><msub><mi>B</mi><mrow><mn>6</mn><mn>2</mn></mrow></msub><mo>[</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">B_{62}[a, a] - B_{62}[a, b]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mord"><span class="mord mathit" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05017em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">6</span><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span><span class="mopen">[</span><span class="mord mathit">a</span><span class="mpunct">,</span><span class="mord rule" style="margin-right:0.16666666666666666em;"></span><span class="mord mathit">a</span><span class="mclose">]</span><span class="mord rule" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mord rule" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathit" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05017em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">6</span><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span><span class="mopen">[</span><span class="mord mathit">a</span><span class="mpunct">,</span><span class="mord rule" style="margin-right:0.16666666666666666em;"></span><span class="mord mathit">b</span><span class="mclose">]</span></span></span></span>. This correction makes sense from a chemical point of view compared to the original edit distance; we will often use the two metrics for comparison.</p>
<h2 class="mume-header" id="benchmarking-generative-models-with-lattice-proteins">Benchmarking Generative Models with Lattice Proteins</h2>

<p>Here, we present an evaluation method for generative models, based on Lattice Proteins <sup class="footnote-ref"><a href="#fn16" id="fnref16">[16]</a></sup>, which has been used to evaluate Restricted Boltzmann Machines <sup class="footnote-ref"><a href="#fn17" id="fnref17">[17]</a></sup>. We demonstrate the relevance of this metric and show that Variational Auto Encoders can be tuned to generate relevant and diverse proteins, outperforming statistical and blosum-inspired models.</p>
<p>Lattice proteins are highly simplified models of proteins, for which the computational effort in handling the model is significantly reduced, although still NP-complete. In the Lattice Protein model, foldings are regarded as paths into multi-dimensionnal grids, called <em>structures</em>:</p>
<img src="/projects/pasteur_images/lp.jpg">
<blockquote>
<p>A path into a 3 x 3 x 3 cubic lattice</p>
</blockquote>
<p>From now on we will only consider paths of size 27 on this 3 x 3 x 3 cubic lattice. There are 103,406 possible structures on this lattice, excluding symmetries, on which a protein composed of 27 amino acids can be folded. Physical interactions between amino acid residues are calculated for residues occupying neighbouring sites on the lattice. Interaction energies for neighbouring amino acids are given by the Miyazawa-Jernigan Energy Matrix <sup class="footnote-ref"><a href="#fn18" id="fnref18">[18]</a></sup> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>E</mi></mrow><annotation encoding="application/x-tex">E</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.05764em;">E</span></span></span></span>: The energy of a sequence <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mo>=</mo><mo>(</mo><msub><mi>a</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>a</mi><mn>2</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><msub><mi>a</mi><mrow><mn>2</mn><mn>7</mn></mrow></msub><mo>)</mo></mrow><annotation encoding="application/x-tex">A = (a_1, a_2, ... a_{27})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mord mathit">A</span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathit">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span><span class="mpunct">,</span><span class="mord rule" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathit">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span><span class="mpunct">,</span><span class="mord rule" style="margin-right:0.16666666666666666em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mord"><span class="mord mathit">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mtight">7</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span><span class="mclose">)</span></span></span></span> folded into a structure <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.05764em;">S</span></span></span></span> is<br>
<span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mi mathvariant="script">E</mi></mrow><mo>(</mo><mi>A</mi><mi mathvariant="normal">∣</mi><mi>S</mi><mo>)</mo><mo>=</mo><munder><mo>∑</mo><mrow><mi>i</mi><mo>&lt;</mo><mi>j</mi></mrow></munder><msubsup><mi>c</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi></mrow><mrow><mo>(</mo><mi>S</mi><mo>)</mo></mrow></msubsup><msub><mi>E</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi></mrow></msub></mrow><annotation encoding="application/x-tex">\mathscr{E}(A\vert S)  = \sum_{i&lt;j} c_{i, j}^{(S)} E_{i, j}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:1.050005em;"></span><span class="strut bottom" style="height:2.463782em;vertical-align:-1.413777em;"></span><span class="base"><span class="mord"><span class="mord mathscr" style="margin-right:0.18583em;">E</span></span><span class="mopen">(</span><span class="mord mathit">A</span><span class="mord">∣</span><span class="mord mathit" style="margin-right:0.05764em;">S</span><span class="mclose">)</span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.050005em;"><span style="top:-1.8723309999999997em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathit mtight">i</span><span class="mrel mtight">&lt;</span><span class="mord mathit mtight" style="margin-right:0.05724em;">j</span></span></span></span><span style="top:-3.0500049999999996em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.413777em;"></span></span></span></span><span class="mord rule" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathit">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0448em;"><span style="top:-2.4231360000000004em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathit mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathit mtight" style="margin-right:0.05724em;">j</span></span></span></span><span style="top:-3.2198em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathit mtight" style="margin-right:0.05764em;">S</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.412972em;"></span></span></span></span></span><span class="mord"><span class="mord mathit" style="margin-right:0.05764em;">E</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathit mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathit mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"></span></span></span></span></span></span></span></span></span><br>
where <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mi>c</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi></mrow><mrow><mo>(</mo><mi>S</mi><mo>)</mo></mrow></msubsup></mrow><annotation encoding="application/x-tex">c_{i, j}^{(S)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:1.0448em;"></span><span class="strut bottom" style="height:1.4577719999999998em;vertical-align:-0.4129719999999999em;"></span><span class="base"><span class="mord"><span class="mord mathit">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0448em;"><span style="top:-2.4231360000000004em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathit mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathit mtight" style="margin-right:0.05724em;">j</span></span></span></span><span style="top:-3.2198em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathit mtight" style="margin-right:0.05764em;">S</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4129719999999999em;"></span></span></span></span></span></span></span></span> is the contact map associated to the structure <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.05764em;">S</span></span></span></span>: <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mi>c</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi></mrow><mrow><mo>(</mo><mi>S</mi><mo>)</mo></mrow></msubsup><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">c_{i, j}^{(S)} = 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:1.0448em;"></span><span class="strut bottom" style="height:1.4577719999999998em;vertical-align:-0.4129719999999999em;"></span><span class="base"><span class="mord"><span class="mord mathit">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0448em;"><span style="top:-2.4231360000000004em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathit mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathit mtight" style="margin-right:0.05724em;">j</span></span></span></span><span style="top:-3.2198em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathit mtight" style="margin-right:0.05764em;">S</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4129719999999999em;"></span></span></span></span></span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mord">1</span></span></span></span> if the amino acids at positions <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.65952em;"></span><span class="strut bottom" style="height:0.65952em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">i</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.65952em;"></span><span class="strut bottom" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.05724em;">j</span></span></span></span> in the protein  sequence are on neighbouring sites in the lattice.</p>
<h3 class="mume-header" id="fitness-score-for-lattice-proteins">Fitness score for lattice proteins</h3>

<p>A Sequence <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">A</span></span></span></span> will natively fold into a structure <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.05764em;">S</span></span></span></span> with a Boltzmann probability that depends on the folding energies on all lattice structures: for unit temperature,<br>
<span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mrow><mi>n</mi><mi>a</mi><mi>t</mi></mrow></msub><mo>(</mo><mi>S</mi><mi mathvariant="normal">∣</mi><mi>A</mi><mo>)</mo><mo>=</mo><mfrac><mrow><msup><mi>e</mi><mrow><mo>−</mo><mrow><mi mathvariant="script">E</mi></mrow><mo>(</mo><mi>A</mi><mo separator="true">,</mo><mi>S</mi><mo>)</mo></mrow></msup></mrow><mrow><munder><mo>∑</mo><msup><mi>S</mi><mo mathvariant="normal">′</mo></msup></munder><msup><mi>e</mi><mrow><mo>−</mo><mrow><mi mathvariant="script">E</mi></mrow><mo>(</mo><mi>A</mi><mo separator="true">,</mo><msup><mi>S</mi><mo mathvariant="normal">′</mo></msup><mo>)</mo></mrow></msup></mrow></mfrac></mrow><annotation encoding="application/x-tex">P_{nat}(S\vert A) = \frac{e^{-\mathscr{E}(A, S)}}{\sum_{S&#x27;} e^{-\mathscr{E}(A, S&#x27;)}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:1.565em;"></span><span class="strut bottom" style="height:2.56871em;vertical-align:-1.0037099999999999em;"></span><span class="base"><span class="mord"><span class="mord mathit" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathit mtight">n</span><span class="mord mathit mtight">a</span><span class="mord mathit mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.05764em;">S</span><span class="mord">∣</span><span class="mord mathit">A</span><span class="mclose">)</span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.565em;"><span style="top:-2.2960000000000003em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.17862099999999992em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathit mtight" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6828285714285715em;"><span style="top:-2.786em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29971000000000003em;"></span></span></span></span></span><span class="mord rule" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathit">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.814em;"><span style="top:-2.989em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight"><span class="mord mathscr mtight" style="margin-right:0.18583em;">E</span></span><span class="mopen mtight">(</span><span class="mord mathit mtight">A</span><span class="mpunct mtight">,</span><span class="mord mtight"><span class="mord mathit mtight" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6828285714285715em;"><span style="top:-2.786em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span></span></span><span style="top:-3.15em;"><span class="pstrut" style="height:3em;"></span><span class="stretchy" style="height:0.2em;"><svg width="400em" height="0.2em" viewBox="0 0 400000 200" preserveAspectRatio="xMinYMin slice"><path d="M0 80H400000 v40H0z M0 80H400000 v40H0z"></path></svg></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathit">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8879999999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight"><span class="mord mathscr mtight" style="margin-right:0.18583em;">E</span></span><span class="mopen mtight">(</span><span class="mord mathit mtight">A</span><span class="mpunct mtight">,</span><span class="mord mathit mtight" style="margin-right:0.05764em;">S</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.0037099999999999em;"></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>
<p>The sequences <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">A</span></span></span></span> that have a high probability of folding into structure <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.05764em;">S</span></span></span></span> are sequences such that they present large gaps between their folding energy in <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.05764em;">S</span></span></span></span> and their folding energies in all other structures  <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>S</mi><mo mathvariant="normal">′</mo></msup></mrow><annotation encoding="application/x-tex">S&#x27;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.751892em;"></span><span class="strut bottom" style="height:0.751892em;vertical-align:0em;"></span><span class="base"><span class="mord"><span class="mord mathit" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span>.</p>
<p>Through Monte Carlo Simulations<sup class="footnote-ref"><a href="#fn16" id="fnref16:1">[16:1]</a></sup><sup>,</sup><sup class="footnote-ref"><a href="#fn19" id="fnref19">[19]</a></sup>, it is possible to create a list of sequences <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>A</mi><mn>1</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><msub><mi>A</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">A_1, .. A_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="base"><span class="mord"><span class="mord mathit">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span><span class="mpunct">,</span><span class="mord rule" style="margin-right:0.16666666666666666em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord"><span class="mord mathit">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span></span></span></span> that have a very high probability (e.g. 0.995) of folding into one specific structure <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.05764em;">S</span></span></span></span>. Starting from a arbitrary sequence <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mn>1</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>a</mi><mrow><mn>2</mn><mn>7</mn></mrow></msub></mrow><annotation encoding="application/x-tex">a_1, .., a_{27}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="base"><span class="mord"><span class="mord mathit">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span><span class="mpunct">,</span><span class="mord rule" style="margin-right:0.16666666666666666em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mpunct">,</span><span class="mord rule" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathit">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mtight">7</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span></span></span></span>, the simulation attempts to make mutations <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub><mo>→</mo><msubsup><mi>a</mi><mi>i</mi><mo mathvariant="normal">′</mo></msubsup></mrow><annotation encoding="application/x-tex">a_i \rightarrow a_i&#x27;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.751892em;"></span><span class="strut bottom" style="height:1.010556em;vertical-align:-0.258664em;"></span><span class="base"><span class="mord"><span class="mord mathit">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mord mathit">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-2.441336em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight">i</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.258664em;"></span></span></span></span></span></span></span></span>, which are accepted if the new folding probability <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mrow><mi>n</mi><mi>a</mi><mi>t</mi></mrow></msub><mo>(</mo><mi>S</mi><mi mathvariant="normal">∣</mi><msup><mi>A</mi><mo mathvariant="normal">′</mo></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">P_{nat}(S\vert A&#x27;)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.751892em;"></span><span class="strut bottom" style="height:1.001892em;vertical-align:-0.25em;"></span><span class="base"><span class="mord"><span class="mord mathit" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathit mtight">n</span><span class="mord mathit mtight">a</span><span class="mord mathit mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.05764em;">S</span><span class="mord">∣</span><span class="mord"><span class="mord mathit">A</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> is higher, and accepted with probability <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><msub><mi>P</mi><mrow><mi>n</mi><mi>a</mi><mi>t</mi></mrow></msub><mo>(</mo><mi>S</mi><mi mathvariant="normal">∣</mi><msup><mi>A</mi><mo mathvariant="normal">′</mo></msup><mo>)</mo><mi mathvariant="normal">/</mi><msub><mi>P</mi><mrow><mi>n</mi><mi>a</mi><mi>t</mi></mrow></msub><mo>(</mo><mi>S</mi><mi mathvariant="normal">∣</mi><mi>A</mi><mo>)</mo><msup><mo>)</mo><mi>β</mi></msup></mrow><annotation encoding="application/x-tex">(P_{nat}(S\vert A&#x27;)/P_{nat}(S\vert A))^{\beta}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8491079999999999em;"></span><span class="strut bottom" style="height:1.0991079999999998em;vertical-align:-0.25em;"></span><span class="base"><span class="mopen">(</span><span class="mord"><span class="mord mathit" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathit mtight">n</span><span class="mord mathit mtight">a</span><span class="mord mathit mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.05764em;">S</span><span class="mord">∣</span><span class="mord"><span class="mord mathit">A</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mord">/</span><span class="mord"><span class="mord mathit" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathit mtight">n</span><span class="mord mathit mtight">a</span><span class="mord mathit mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.05764em;">S</span><span class="mord">∣</span><span class="mord mathit">A</span><span class="mclose">)</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathit mtight" style="margin-right:0.05278em;">β</span></span></span></span></span></span></span></span></span></span></span></span> otherwise, where <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>β</mi></mrow><annotation encoding="application/x-tex">\beta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.05278em;">β</span></span></span></span> plays the role of an inverse temperature, which helps the simulation escape local minimas in the energy function.</p>
<blockquote>
<p>It is also possible to add a bias term in the corresponding Hamiltonian to account for phylogenetic effects in sequence mutation<sup class="footnote-ref"><a href="#fn16" id="fnref16:2">[16:2]</a></sup>.</p>
</blockquote>
<p>The resulting sequences share a non-trivial high-order folding property while being very different from one another. The folding score into the structure <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.05764em;">S</span></span></span></span> can therefore be seen as an evaluation metric for generative models.</p>
<h3>Methods</h3>
<p>H. Jacquin, A. Gilson, E. Shakhnovich, S. Cocco, &amp; R. Monasson made available four lists of proteins that fold natively into four lattice structures, that is available for download <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4866778/bin/pcbi.1004889.s002.zip">here</a>.</p>
<p>Hereafter, we consider the lattice structure <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>S</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">S_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="base"><span class="mord"><span class="mord mathit" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span></span></span></span> with its list of ~ 50,000 proteins of size 27 that fold into <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>S</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">S_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="base"><span class="mord"><span class="mord mathit" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span></span></span></span> with probability <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="base"><span class="mord mathit">p</span></span></span></span> &gt; 0.99.</p>
<p>We implement a variational auto-encoder (VAE) that learns a compressed representation of this dataset of proteins, and then generate new proteins by sampling the latent space distribution. We then score the generative model based on three metrics:</p>
<ul>
<li>The folding score of the generated sequences. For convenience, we use for each sequence <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">A</span></span></span></span> the scoring  function <span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>(</mo><mi>A</mi><mo>)</mo><mo>=</mo><mo>−</mo><mi>l</mi><mi>n</mi><mo>(</mo><mn>1</mn><mo>−</mo><msub><mi>P</mi><mrow><mi>n</mi><mi>a</mi><mi>t</mi></mrow></msub><mo>(</mo><msub><mi>S</mi><mn>0</mn></msub><mi mathvariant="normal">∣</mi><mi>A</mi><mo>)</mo><mo>)</mo></mrow><annotation encoding="application/x-tex">f(A) = - ln(1-P_{nat}(S_0\vert A))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathit">A</span><span class="mclose">)</span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mord">−</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mord mathit">n</span><span class="mopen">(</span><span class="mord">1</span><span class="mord rule" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mord rule" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathit" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathit mtight">n</span><span class="mord mathit mtight">a</span><span class="mord mathit mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathit" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span><span class="mord">∣</span><span class="mord mathit">A</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span></span></li>
<li>The smallest edit distance between a generated sequence and the train dataset.</li>
<li>The histogram of pairwise distances in the generated sequences.</li>
</ul>
<p>Indeed, a good generative model should be able to generate sequences that fold into structure <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>S</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">S_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="base"><span class="mord"><span class="mord mathit" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span></span></span></span>, while being significantly different from the dataset. Moreover, the pairwise distances distribution of the generated sequences should correspond to the one of the original dataset.</p>
<p>We use the following baseline models to assess the relevance of Variational Auto Encoders:</p>
<ul>
<li><strong>Blosum Model</strong>: The Blosum 62 Matrix indicates which amino-acids can easily be replaced by one another in the sequence of a protein. Therefore, we can use this matrix to generate variants of a protein, by choosing some positions and changing the amino-acids at those positions to closely related amino-acids.</li>
<li><strong>MSA Model</strong>: In a multiple sequence alignment, it is critical that some positions are occupied by a particular amino-acid. We can use this property to generate variants: For each position <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.65952em;"></span><span class="strut bottom" style="height:0.65952em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">i</span></span></span></span>, we can decide to change the amino-acid at this position to another one by sampling the distribution of amino-acids at this very position.</li>
</ul>
<p>We study a Variational Auto-Encoder with 5 layers (including input and output layers), that we call VAE<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mrow></mrow><mrow><mn>1</mn><mn>0</mn></mrow></msub></mrow><annotation encoding="application/x-tex">_{10}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.30110799999999993em;"></span><span class="strut bottom" style="height:0.45110799999999995em;vertical-align:-0.15em;"></span><span class="base"><span class="mord"><span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span></span></span></span>. Below is the graph of this VAE: In each cell are indicated the size of the layer (number of artificial neurons).</p>
<div class="mermaid">graph LR
A("Input <br>(21, 27)") -- Flatten --> B
B("Intermediate <br>Dense (50)") --> ZA("z_mean<br> Dense (10)")
B --> ZB("z_log_sigma<br>Dense (10)")
ZA --> Z("z_sample<br>Sample (10)")
ZB --> Z
Z --> C("Intermediate<br>Dense (50)")
C -- Reshape --> Output("Output<br> Dense (21, 27)")
</div><p>where z_sample is sampled from a gaussian distribution with mean <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>z</mi><mrow><mi>m</mi><mi>e</mi><mi>a</mi><mi>m</mi></mrow></msub></mrow><annotation encoding="application/x-tex">z_{meam}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="base"><span class="mord"><span class="mord mathit" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.04398em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathit mtight">m</span><span class="mord mathit mtight">e</span><span class="mord mathit mtight">a</span><span class="mord mathit mtight">m</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span></span></span></span> and variance <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>e</mi><msub><mi>z</mi><mrow><mi>l</mi><mi>o</mi><mi>g</mi><mi mathvariant="normal">_</mi><mi>s</mi><mi>i</mi><mi>g</mi><mi>m</mi><mi>a</mi></mrow></msub></msup></mrow><annotation encoding="application/x-tex">e^{z_{log\_sigma}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.670002em;"></span><span class="strut bottom" style="height:0.670002em;vertical-align:0em;"></span><span class="base"><span class="mord"><span class="mord mathit">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.670002em;"><span style="top:-3.0686100000000005em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathit mtight" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3487714285714287em;margin-left:-0.04398em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathit mtight" style="margin-right:0.01968em;">l</span><span class="mord mathit mtight">o</span><span class="mord mathit mtight" style="margin-right:0.03588em;">g</span><span class="mord mtight" style="margin-right:0.02778em;">_</span><span class="mord mathit mtight">s</span><span class="mord mathit mtight">i</span><span class="mord mathit mtight" style="margin-right:0.03588em;">g</span><span class="mord mathit mtight">m</span><span class="mord mathit mtight">a</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3726571428571428em;"></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>:<br>
<span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>z</mi><mrow><mi>s</mi><mi>a</mi><mi>m</mi><mi>p</mi><mi>l</mi><mi>e</mi></mrow></msub><mo>∼</mo><mrow><mi mathvariant="script">N</mi></mrow><mo>(</mo><msub><mi>z</mi><mrow><mi>m</mi><mi>e</mi><mi>a</mi><mi>n</mi></mrow></msub><mo separator="true">,</mo><msup><mi>e</mi><msub><mi>z</mi><mrow><mi>l</mi><mi>o</mi><mi>g</mi><mi mathvariant="normal">_</mi><mi>s</mi><mi>i</mi><mi>g</mi><mi>m</mi><mi>a</mi></mrow></msub></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">z_{sample} \sim \mathscr{N}(z_{mean}, e^{z_{log\_sigma}})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="base"><span class="mord"><span class="mord mathit" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.04398em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathit mtight">s</span><span class="mord mathit mtight">a</span><span class="mord mathit mtight">m</span><span class="mord mathit mtight">p</span><span class="mord mathit mtight" style="margin-right:0.01968em;">l</span><span class="mord mathit mtight">e</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"></span></span></span></span></span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∼</span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mord mathscr" style="margin-right:0.3525em;">N</span></span><span class="mopen">(</span><span class="mord"><span class="mord mathit" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.04398em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathit mtight">m</span><span class="mord mathit mtight">e</span><span class="mord mathit mtight">a</span><span class="mord mathit mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span><span class="mpunct">,</span><span class="mord rule" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathit">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.714392em;"><span style="top:-3.1130000000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathit mtight" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3487714285714287em;margin-left:-0.04398em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathit mtight" style="margin-right:0.01968em;">l</span><span class="mord mathit mtight">o</span><span class="mord mathit mtight" style="margin-right:0.03588em;">g</span><span class="mord mtight" style="margin-right:0.02778em;">_</span><span class="mord mathit mtight">s</span><span class="mord mathit mtight">i</span><span class="mord mathit mtight" style="margin-right:0.03588em;">g</span><span class="mord mathit mtight">m</span><span class="mord mathit mtight">a</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3726571428571428em;"></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span></p>
<p>We will also review a VAE with the same structure and more parameters, the VAE<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mrow></mrow><mrow><mn>3</mn><mn>0</mn></mrow></msub></mrow><annotation encoding="application/x-tex">_{30}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.30110799999999993em;"></span><span class="strut bottom" style="height:0.45110799999999995em;vertical-align:-0.15em;"></span><span class="base"><span class="mord"><span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span></span></span></span>:</p>
<div class="mermaid">graph LR
A("Input <br>(21, 27)") -- Flatten --> B
B("Intermediate <br>Dense (200)") --> ZA("z_mean<br> Dense (30)")
B --> ZB("z_log_sigma<br>Dense (30)")
ZA --> Z("z_sample<br>Sample (30)")
ZB --> Z
Z --> C("Intermediate<br>Dense (200)")
C -- Reshape --> Output("Output<br> Dense (21, 27)")
</div><p>These networks are trained with a loss <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>L</mi><mo>=</mo><msub><mi>L</mi><mrow><mi>c</mi><mi>r</mi><mi>o</mi><mi>s</mi><mi>s</mi><mi mathvariant="normal">_</mi><mi>e</mi><mi>n</mi><mi>t</mi><mi>r</mi><mi>o</mi><mi>p</mi><mi>y</mi></mrow></msub><mo>+</mo><msub><mi>L</mi><mrow><mi>K</mi><mi>L</mi><mi mathvariant="normal">_</mi><mi>d</mi><mi>i</mi><mi>v</mi></mrow></msub></mrow><annotation encoding="application/x-tex">L = L_{cross\_entropy} + L_{KL\_div}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:1.05033em;vertical-align:-0.367em;"></span><span class="base"><span class="mord mathit">L</span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mord mathit">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathit mtight">c</span><span class="mord mathit mtight" style="margin-right:0.02778em;">r</span><span class="mord mathit mtight">o</span><span class="mord mathit mtight">s</span><span class="mord mathit mtight">s</span><span class="mord mtight" style="margin-right:0.02778em;">_</span><span class="mord mathit mtight">e</span><span class="mord mathit mtight">n</span><span class="mord mathit mtight">t</span><span class="mord mathit mtight" style="margin-right:0.02778em;">r</span><span class="mord mathit mtight">o</span><span class="mord mathit mtight">p</span><span class="mord mathit mtight" style="margin-right:0.03588em;">y</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.367em;"></span></span></span></span></span><span class="mord rule" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mord rule" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathit">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathit mtight" style="margin-right:0.07153em;">K</span><span class="mord mathit mtight">L</span><span class="mord mtight" style="margin-right:0.02778em;">_</span><span class="mord mathit mtight">d</span><span class="mord mathit mtight">i</span><span class="mord mathit mtight" style="margin-right:0.03588em;">v</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.367em;"></span></span></span></span></span></span></span></span><sup class="footnote-ref"><a href="#fn8" id="fnref8:1">[8:1]</a></sup>, with<br>
<span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>L</mi><mrow><mi>c</mi><mi>r</mi><mi>o</mi><mi>s</mi><mi>s</mi><mi mathvariant="normal">_</mi><mi>e</mi><mi>n</mi><mi>t</mi><mi>r</mi><mi>o</mi><mi>p</mi><mi>y</mi></mrow></msub><mo>(</mo><mi>x</mi><mo separator="true">,</mo><msup><mi>x</mi><mo mathvariant="normal">′</mo></msup><mo>)</mo><mo>=</mo><mi>x</mi><mi>l</mi><mi>o</mi><mi>g</mi><mo>(</mo><msup><mi>x</mi><mo mathvariant="normal">′</mo></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">L_{cross\_entropy}(x, x&#x27;) = x log(x&#x27;)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.801892em;"></span><span class="strut bottom" style="height:1.168892em;vertical-align:-0.367em;"></span><span class="base"><span class="mord"><span class="mord mathit">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathit mtight">c</span><span class="mord mathit mtight" style="margin-right:0.02778em;">r</span><span class="mord mathit mtight">o</span><span class="mord mathit mtight">s</span><span class="mord mathit mtight">s</span><span class="mord mtight" style="margin-right:0.02778em;">_</span><span class="mord mathit mtight">e</span><span class="mord mathit mtight">n</span><span class="mord mathit mtight">t</span><span class="mord mathit mtight" style="margin-right:0.02778em;">r</span><span class="mord mathit mtight">o</span><span class="mord mathit mtight">p</span><span class="mord mathit mtight" style="margin-right:0.03588em;">y</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.367em;"></span></span></span></span></span><span class="mopen">(</span><span class="mord mathit">x</span><span class="mpunct">,</span><span class="mord rule" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathit">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.801892em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mord mathit">x</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mord mathit">o</span><span class="mord mathit" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord"><span class="mord mathit">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.801892em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span> <span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>L</mi><mrow><mi>K</mi><mi>L</mi><mi mathvariant="normal">_</mi><mi>d</mi><mi>i</mi><mi>v</mi></mrow></msub><mo>=</mo><mfrac><mrow><mn>1</mn></mrow><mrow><mn>2</mn></mrow></mfrac><mo>(</mo><msubsup><mi>z</mi><mrow><mi>m</mi><mi>e</mi><mi>a</mi><mi>n</mi></mrow><mn>2</mn></msubsup><mo>+</mo><msup><mi>e</mi><msub><mi>z</mi><mrow><mi>l</mi><mi>o</mi><mi>g</mi><mi mathvariant="normal">_</mi><mi>s</mi><mi>i</mi><mi>g</mi><mi>m</mi><mi>a</mi></mrow></msub></msup><mo>−</mo><msub><mi>z</mi><mrow><mi>l</mi><mi>o</mi><mi>g</mi><mi mathvariant="normal">_</mi><mi>s</mi><mi>i</mi><mi>g</mi><mi>m</mi><mi>a</mi></mrow></msub><mo>−</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">L_{KL\_div} = \frac{1}{2}(z_{mean}^2 + e^{z_{log\_sigma}} - z_{log\_sigma} - 1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:1.32144em;"></span><span class="strut bottom" style="height:2.00744em;vertical-align:-0.686em;"></span><span class="base"><span class="mord"><span class="mord mathit">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathit mtight" style="margin-right:0.07153em;">K</span><span class="mord mathit mtight">L</span><span class="mord mtight" style="margin-right:0.02778em;">_</span><span class="mord mathit mtight">d</span><span class="mord mathit mtight">i</span><span class="mord mathit mtight" style="margin-right:0.03588em;">v</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.367em;"></span></span></span></span></span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-3.15em;"><span class="pstrut" style="height:3em;"></span><span class="stretchy" style="height:0.2em;"><svg width="400em" height="0.2em" viewBox="0 0 400000 200" preserveAspectRatio="xMinYMin slice"><path d="M0 80H400000 v40H0z M0 80H400000 v40H0z"></path></svg></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathit" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-2.4530000000000003em;margin-left:-0.04398em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathit mtight">m</span><span class="mord mathit mtight">e</span><span class="mord mathit mtight">a</span><span class="mord mathit mtight">n</span></span></span></span><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"></span></span></span></span></span><span class="mord rule" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mord rule" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathit">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.714392em;"><span style="top:-3.1130000000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathit mtight" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3487714285714287em;margin-left:-0.04398em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathit mtight" style="margin-right:0.01968em;">l</span><span class="mord mathit mtight">o</span><span class="mord mathit mtight" style="margin-right:0.03588em;">g</span><span class="mord mtight" style="margin-right:0.02778em;">_</span><span class="mord mathit mtight">s</span><span class="mord mathit mtight">i</span><span class="mord mathit mtight" style="margin-right:0.03588em;">g</span><span class="mord mathit mtight">m</span><span class="mord mathit mtight">a</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3726571428571428em;"></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="mord rule" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mord rule" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathit" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.04398em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathit mtight" style="margin-right:0.01968em;">l</span><span class="mord mathit mtight">o</span><span class="mord mathit mtight" style="margin-right:0.03588em;">g</span><span class="mord mtight" style="margin-right:0.02778em;">_</span><span class="mord mathit mtight">s</span><span class="mord mathit mtight">i</span><span class="mord mathit mtight" style="margin-right:0.03588em;">g</span><span class="mord mathit mtight">m</span><span class="mord mathit mtight">a</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.367em;"></span></span></span></span></span><span class="mord rule" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mord rule" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span></span></p>
<p>Roughly speaking, the first term is the reconstruction accuracy between a protein <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">x</span></span></span></span> and its reconstructed sequence <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>x</mi><mo mathvariant="normal">′</mo></msup></mrow><annotation encoding="application/x-tex">x&#x27;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.751892em;"></span><span class="strut bottom" style="height:0.751892em;vertical-align:0em;"></span><span class="base"><span class="mord"><span class="mord mathit">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span>: The lower the loss, the closer <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">x</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>x</mi><mo mathvariant="normal">′</mo></msup></mrow><annotation encoding="application/x-tex">x&#x27;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.751892em;"></span><span class="strut bottom" style="height:0.751892em;vertical-align:0em;"></span><span class="base"><span class="mord"><span class="mord mathit">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span> are.<br>
The KL Divergence loss measures how far the distribution of the latent variable <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>z</mi><mrow><mi>m</mi><mi>e</mi><mi>a</mi><mi>n</mi></mrow></msub></mrow><annotation encoding="application/x-tex">z_{mean}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="base"><span class="mord"><span class="mord mathit" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.04398em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathit mtight">m</span><span class="mord mathit mtight">e</span><span class="mord mathit mtight">a</span><span class="mord mathit mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span></span></span></span> is from a gaussian distribution <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mi mathvariant="script">N</mi></mrow><mo>(</mo><mn>0</mn><mo separator="true">,</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">\mathscr{N}(0, 1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mord"><span class="mord mathscr" style="margin-right:0.3525em;">N</span></span><span class="mopen">(</span><span class="mord">0</span><span class="mpunct">,</span><span class="mord rule" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span>.</p>
<p>By minimizing the loss <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>L</mi></mrow><annotation encoding="application/x-tex">L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">L</span></span></span></span>,  the model both learns to reconstruct the proteins of the training set  and to model these proteins with a latent distribution that is close to a gaussian distribution <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mi mathvariant="script">N</mi></mrow><mo>(</mo><mn>0</mn><mo separator="true">,</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">\mathscr{N}(0, 1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mord"><span class="mord mathscr" style="margin-right:0.3525em;">N</span></span><span class="mopen">(</span><span class="mord">0</span><span class="mpunct">,</span><span class="mord rule" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span>.</p>
<p>A new variant of a protein <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">x</span></span></span></span> is then calculated with the following algorithm</p>
<ul>
<li>compute <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>z</mi><mrow><mi>m</mi><mi>e</mi><mi>a</mi><mi>n</mi></mrow></msub></mrow><annotation encoding="application/x-tex">z_{mean}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="base"><span class="mord"><span class="mord mathit" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.04398em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathit mtight">m</span><span class="mord mathit mtight">e</span><span class="mord mathit mtight">a</span><span class="mord mathit mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span></span></span></span> and <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>z</mi><mrow><mi>v</mi><mi>a</mi><mi>r</mi></mrow></msub></mrow><annotation encoding="application/x-tex">z_{var}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="base"><span class="mord"><span class="mord mathit" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.04398em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathit mtight" style="margin-right:0.03588em;">v</span><span class="mord mathit mtight">a</span><span class="mord mathit mtight" style="margin-right:0.02778em;">r</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span></span></span></span> with the encoder network</li>
<li>sample <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>z</mi><mo>=</mo><msub><mi>z</mi><mrow><mi>m</mi><mi>e</mi><mi>a</mi><mi>n</mi></mrow></msub><mo>+</mo><mi>r</mi><mo>∗</mo><msub><mi>z</mi><mrow><mi>v</mi><mi>a</mi><mi>r</mi></mrow></msub></mrow><annotation encoding="application/x-tex">z = z_{mean} + r * z_{var}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.58333em;"></span><span class="strut bottom" style="height:0.73333em;vertical-align:-0.15em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.04398em;">z</span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mord mathit" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.04398em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathit mtight">m</span><span class="mord mathit mtight">e</span><span class="mord mathit mtight">a</span><span class="mord mathit mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span><span class="mord rule" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mord rule" style="margin-right:0.2222222222222222em;"></span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mord rule" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mord rule" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathit" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.04398em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathit mtight" style="margin-right:0.03588em;">v</span><span class="mord mathit mtight">a</span><span class="mord mathit mtight" style="margin-right:0.02778em;">r</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span></span></span></span> where <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi><mo>∼</mo><mrow><mi mathvariant="script">N</mi></mrow><mo>(</mo><mn>0</mn><mo separator="true">,</mo><mi>s</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">r \sim \mathscr{N}(0, s)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∼</span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mord mathscr" style="margin-right:0.3525em;">N</span></span><span class="mopen">(</span><span class="mord">0</span><span class="mpunct">,</span><span class="mord rule" style="margin-right:0.16666666666666666em;"></span><span class="mord mathit">s</span><span class="mclose">)</span></span></span></span></li>
<li>Decode <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>z</mi></mrow><annotation encoding="application/x-tex">z</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.04398em;">z</span></span></span></span> into a new protein <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>x</mi><mo mathvariant="normal">′</mo></msup></mrow><annotation encoding="application/x-tex">x&#x27;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.751892em;"></span><span class="strut bottom" style="height:0.751892em;vertical-align:0em;"></span><span class="base"><span class="mord"><span class="mord mathit">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span> with the decoder network.</li>
</ul>
<p>The parameter <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">s</span></span></span></span> is the sampling factor. During training, <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">s = 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.64444em;"></span><span class="strut bottom" style="height:0.64444em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">s</span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mord">1</span></span></span></span>, but during test time, we can take larger values of <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">s</span></span></span></span> to generate more distant variants.</p>
<h3 class="mume-header" id="results">Results</h3>

<p>Here, we show a scatter plot of the data generated with the Msa Model, the blosum Model, the VAEs with a latent space of size 10 and 30, and some data from the original protein dataset kept as test dataset. The parameter <code>stddev</code> corresponds to the sampling factor <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">s</span></span></span></span> during generation of variants for the VAEs. Each point (x, y) in the graph is a variant <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">A</span></span></span></span> of a protein in the training set, where x is the smallest edit distance to the proteins of the training set and y is the folding score <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>(</mo><mi>A</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">f(A)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathit">A</span><span class="mclose">)</span></span></span></span> relative to the structure <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>S</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">S_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="base"><span class="mord"><span class="mord mathit" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span></span></span></span>. Across different generative models, points are slightly shifted on the x axis to improve visibility.</p>
<img src="/projects/pasteur_images/bokeh_plot_lp.png">
<ul>
<li>The baseline models gives very poor results: The generated sequences fail to fold natively into the structure <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>S</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">S_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="base"><span class="mord"><span class="mord mathit" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span></span></span></span>. Only 6% of the sequences generated with the blosum model fold into <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>S</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">S_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="base"><span class="mord"><span class="mord mathit" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span></span></span></span> with probability higher than 85%. The MSA Model is slightly better with 25% generated sequences folding with a probability higher than 85%. These models are very far from the sequences scores of the test dataset, as expected, due to the complexity of the metric.</li>
<li>The Two Variational AutoEncoders, tested with a sampling factor of 3, give different results: They are both able to generate high-quality sequences that fold into <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>S</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">S_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="base"><span class="mord"><span class="mord mathit" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span></span></span></span> with probability &gt;98% for 98% of them. However, the more complex VAE with a latent space of size 30 generates samples that are closer to the training set: Indeed, this network is able to better reconstruct the input sequences, with a reconstruction accuracy of 85%. The VAE<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mrow></mrow><mrow><mn>1</mn><mn>0</mn></mrow></msub></mrow><annotation encoding="application/x-tex">_{10}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.30110799999999993em;"></span><span class="strut bottom" style="height:0.45110799999999995em;vertical-align:-0.15em;"></span><span class="base"><span class="mord"><span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span></span></span></span> has a reconstruction accuracy of only 53%, but this does not impact the folding score of its generated sequences. As a result, these sequences are quite distant from the training set, with a minimum Hamming Distance of 11 on average, which corresponds to a maximum sequence homology of 60% between a protein and its closest sequence in the training set.</li>
<li>It is possible to obtain more distant variants with the VAE<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mrow></mrow><mrow><mn>3</mn><mn>0</mn></mrow></msub></mrow><annotation encoding="application/x-tex">_{30}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.30110799999999993em;"></span><span class="strut bottom" style="height:0.45110799999999995em;vertical-align:-0.15em;"></span><span class="base"><span class="mord"><span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span></span></span></span> by increasing the sampling factor up to 25. The generated sequences are then more distant from the training set, but this has a drastic impact on the folding score: Only 35% of the proteins are able to fold correctly with a probability of 98%, and 13% have a folding probability below 85%.</li>
</ul>
<p>From the above remarks, we understand that:</p>
<ul>
<li>Statistical Methods and bio-inspired methods fail to generated sequences that have the same folding property as the training sequences.</li>
<li>The quality of reconstruction is not a good metric regarding the goal of generating sequences that are both distant from the training set and have a good folding score.</li>
<li>A smaller latent space size for a VAE can help to capture a simpler representation of the training sequences without affecting the folding score.</li>
</ul>
<h3 class="mume-header" id="variants-diversity">Variants Diversity</h3>

<p>The VAE<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mrow></mrow><mrow><mn>1</mn><mn>0</mn></mrow></msub></mrow><annotation encoding="application/x-tex">_{10}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.30110799999999993em;"></span><span class="strut bottom" style="height:0.45110799999999995em;vertical-align:-0.15em;"></span><span class="base"><span class="mord"><span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span></span></span></span> models the data distribution correctly with respect to the folding metric and is able to generate new proteins distant from the training set. But are the generated samples distant from one another ? Here, we compute the pairwise distance between the generated samples, and compare it with the &quot;true&quot; pairwise distance distribution of the test dataset. Distances are evaluated using the B62 distance, as discussed in the introduction.<br>
Here is the histogram of pairwise distances between proteins, for the test dataset and for the Auto Encoder variants.</p>
<img src="/projects/pasteur_images/pairwise_hist.png">
<p>We can see that the VAE<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mrow></mrow><mrow><mn>1</mn><mn>0</mn></mrow></msub></mrow><annotation encoding="application/x-tex">_{10}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.30110799999999993em;"></span><span class="strut bottom" style="height:0.45110799999999995em;vertical-align:-0.15em;"></span><span class="base"><span class="mord"><span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span></span></span></span> model generates samples that are as diverse as the original set of proteins, which is what we desired.</p>
<h1 class="mume-header" id="generating-variants-of-luciferase-enzymes">Generating variants of Luciferase Enzymes</h1>

<p>We have seen that Variational Auto Encoders with a simple architecture are able to model complex distributions and preserve the structure of a protein in the Lattice Proteins Model, as measured by the folding accuracy metric. However, in this model, all the proteins have a fixed size of 27 amino-acids, which is not biologically relevant: In reality, most proteins have a length of hundreds, sometimes thousands of amino-acids. We will now study a much more complex family of real-life proteins: the Luciferase domain, a group of enzymes that all catalyze the same bio-chemical reaction, which can in some cases produce light. We will model the distribution of these proteins with a more complex VAE, and will try to assess whether this model generates interesting proteins by investigating its ability to understand basic properties about amino-acids and extrapolate the general folding structure of the Luciferase domain.</p>
<h2 class="mume-header" id="background">Background</h2>

<h3 class="mume-header" id="the-bac-luciferase-family">The Bac Luciferase Family</h3>

<p>Luciferase is a generic term for the class of oxidative enzymes that produce bioluminescence. They are found in a variety of organisms, including fireflies, jellyfish and bacteria. Luciferases  catalyze a chemical reaction which consumes a substrate called luciferin and produces a blue-green light. Luciferases can be produced in the lab through genetic engineering for a number of purposes. Photo emission can be detected by appropriate light detector, which allows for observation of biological processes, among other things.</p>
<p>Luciferase are organized, as all other proteins, in a hierarchy representative of the natural evolution. A protein family is a set of proteins that share a common ancestor, reflected by their related functions and similarities in sequences and structure. Families of proteins that display a common evolutionary origin are called superfamilies. Databases of the Luciferase superfamily can be found online on PFAM  (<a href="https://pfam.xfam.org/family/PF00296">PF00296</a>) and INTERPRO (<a href="https://www.ebi.ac.uk/interpro/entry/IPR011251">IPR011251</a>). These databases are build based on sequence identity, and gather proteins responsible for a unique oxidative process that does not always result in light emission. It means that most proteins in the dataset do not effectively produce light and it might also be that they catalyze side-reactions.</p>
<p>Moreover, there is a high sampling bias in this dataset: some proteins have a high sequence homology, which is defined as the percentage of amino-acids that two proteins have in common (after alignment). We call a cluster50 a set of proteins that have a pairwise sequence homology of more than 50% and a cluster90 a set of proteins that have a pairwise sequence homology of more than 90%. When not specified, a &quot;cluster&quot; will refer to a cluster50.</p>
<h3>Modern Auto-Encoders</h3>
<p>We already presented Variational Auto Encoders, that learn a compressed and meaningful representation of a dataset through an information bottleneck. When generating images, VAEs capture the global structure of the data, but the images they generate by sampling the latent space tend to be blurry as high-frequency details in the input images (edges, textures...) tend to disappear because they do not carry enough information. To solve this issue, it has been proposed to use an autoregressive decoder in a VAE <sup class="footnote-ref"><a href="#fn20" id="fnref20">[20]</a></sup>. In an autoregressive model, each pixel is generated as the next element in a sequence, given both the latent vector of the image and the previously generated pixels: the joint data distribution is  modeled as <span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mi mathvariant="double-struck">P</mi></mrow><mo>(</mo><mi>X</mi><mi mathvariant="normal">∣</mi><mi>z</mi><mo>)</mo><mo>=</mo><munderover><mo>∏</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>N</mi></munderover><mrow><mi mathvariant="double-struck">P</mi></mrow><mo>(</mo><msub><mi>x</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub><mi mathvariant="normal">∣</mi><mi>z</mi><mo separator="true">,</mo><msub><mi>x</mi><mn>1</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>x</mi><mi>i</mi></msub><mo>)</mo></mrow><annotation encoding="application/x-tex">\mathbb{P}(X\vert z) = \prod_{i=1}^N \mathbb{P}(x_{i+1} \vert z, x_1, ..., x_i)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:1.8283360000000002em;"></span><span class="strut bottom" style="height:3.106005em;vertical-align:-1.277669em;"></span><span class="base"><span class="mord"><span class="mord mathbb">P</span></span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.07847em;">X</span><span class="mord">∣</span><span class="mord mathit" style="margin-right:0.04398em;">z</span><span class="mclose">)</span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.8283360000000002em;"><span style="top:-1.872331em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathit mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∏</span></span></span><span style="top:-4.3000050000000005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight" style="margin-right:0.10903em;">N</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.277669em;"></span></span></span></span><span class="mord rule" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathbb">P</span></span><span class="mopen">(</span><span class="mord"><span class="mord mathit">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathit mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"></span></span></span></span></span><span class="mord">∣</span><span class="mord mathit" style="margin-right:0.04398em;">z</span><span class="mpunct">,</span><span class="mord rule" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathit">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span><span class="mpunct">,</span><span class="mord rule" style="margin-right:0.16666666666666666em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mpunct">,</span><span class="mord rule" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathit">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span><span class="mclose">)</span></span></span></span></span><br>
Autoregressive models, such as Recurrent Neural Networks (especially LSTM and GRU architectures <sup class="footnote-ref"><a href="#fn21" id="fnref21">[21]</a></sup> <sup class="footnote-ref"><a href="#fn22" id="fnref22">[22]</a></sup>) have been used to model long range dependencies in time series but they are quite long to train, Alternatively, causal (or masked) convolutions offer a convenient framework to model sequences with long-range dependencies, with a comparable performance while being trainable much faster in parallel <sup class="footnote-ref"><a href="#fn23" id="fnref23">[23]</a></sup>. Causal convolutions ensure that prediction of a point only depends on the previous point <sup class="footnote-ref"><a href="#fn24" id="fnref24">[24]</a></sup> <sup class="footnote-ref"><a href="#fn25" id="fnref25">[25]</a></sup> <sup class="footnote-ref"><a href="#fn26" id="fnref26">[26]</a></sup>.</p>
<p>Another major improvement to classical VAE is the possibility to remove some high level features from the latent space and pass them as extra-parameters, when the dataset is annotated with these high-level features. After training, one can then manually change these high-level features to produce samples with desired properties. This is called conditioning.</p>
<p>Finally, it has been shown that the use of gated activation functions <sup class="footnote-ref"><a href="#fn24" id="fnref24:1">[24:1]</a></sup> <sup class="footnote-ref"><a href="#fn27" id="fnref27">[27]</a></sup> can substantially increase performance.</p>
<p>We present here a conditional VAE, whose decoder is an autoregressive model strongly inspired by the Wavenet architecture <sup class="footnote-ref"><a href="#fn20" id="fnref20:1">[20:1]</a></sup> <sup class="footnote-ref"><a href="#fn28" id="fnref28">[28]</a></sup>. We will condition the generated sequences upon some physical properties of the proteins that are not directly encoded in the amino-acid sequence but calculated via an external software.</p>
<h2 class="mume-header" id="model-details">Model Details</h2>

<h3 class="mume-header" id="architecture">Architecture</h3>

<p>The architecture of our model is the following:</p>
<div class="mermaid">graph LR
x((x))
c((c))
z((z))
E(Encoder)
subgraph Decoder
U(Up Sampling)
A(Autoregressive Model)
z'((z'))
end
x --> A
c --> E
x --> E
E --> z
z --> U
c --> U
U -->z'
z' --> A
A --> x'((x'))
style E fill:#ada
style U fill:#ada
style A fill:#ada
</div><p>The vector x is a one-hot encoding of the protein: With 21 amino-acids (including a padding character) and a length of 300, the one-hot encoding have a shape of (300, 21).<br>
The vector c contains the physical quantities of the protein we condition upon: the length of the protein, its charge, its isoelectric point, its molar extinction coefficient, its solubility, and its molecular weight. These quantities are estimated using the <em>pepstats</em> tool from the EMBOSS software suite <sup class="footnote-ref"><a href="#fn29" id="fnref29">[29]</a></sup>, and then normalized to have null mean and unit variance.<br>
During training, the vectors x and c are encoded into a latent space variable z.  z is then upsampled conditioning on c, generating z' which is then passed to the autoregressive model that reconstructs x'.</p>
<p>The encoder network has the following architecture:</p>
<div class="mermaid">graph LR
x((x)) --> L1(5 x Conv 1D)
c((c)) --> D1(2 x Dense)
L1 -- Flatten --> C(Concat)
D1 --> C
C --> DD(2 x Dense)
DD --> STD("Dense + Softplus + Sqrt : z_std")
DD --> MEAN("Dense : z_mean")
STD --> S(Sample z)
MEAN --> S
style L1 fill:#daa
style D1 fill:#ada
style DD fill:#ada
style STD fill:#ada
style MEAN fill:#ada
style C fill:#dda
</div><blockquote>
<p>All convolutions have a stride of 2, and the number of filters is doubled each time. The Sample Layer computes <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>z</mi><mo>=</mo><msub><mi>z</mi><mrow><mi>m</mi><mi>e</mi><mi>a</mi><mi>n</mi></mrow></msub><mo>+</mo><mi>r</mi><mo>∗</mo><msub><mi>z</mi><mrow><mi>s</mi><mi>t</mi><mi>d</mi></mrow></msub></mrow><annotation encoding="application/x-tex">z = z_{mean} + r * z_{std}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.58333em;"></span><span class="strut bottom" style="height:0.73333em;vertical-align:-0.15em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.04398em;">z</span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mord mathit" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.04398em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathit mtight">m</span><span class="mord mathit mtight">e</span><span class="mord mathit mtight">a</span><span class="mord mathit mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span><span class="mord rule" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mord rule" style="margin-right:0.2222222222222222em;"></span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mord rule" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mord rule" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathit" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.04398em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathit mtight">s</span><span class="mord mathit mtight">t</span><span class="mord mathit mtight">d</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span></span></span></span> where <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi><mo>∼</mo><mrow><mi mathvariant="script">N</mi></mrow><mo>(</mo><mn>0</mn><mo separator="true">,</mo><mi>s</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">r \sim \mathscr{N}(0, s)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∼</span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mord mathscr" style="margin-right:0.3525em;">N</span></span><span class="mopen">(</span><span class="mord">0</span><span class="mpunct">,</span><span class="mord rule" style="margin-right:0.16666666666666666em;"></span><span class="mord mathit">s</span><span class="mclose">)</span></span></span></span>.</p>
</blockquote>
<p>The UpSampling Network is</p>
<div class="mermaid">graph LR
c((c)) --> C(Concat)
C --> D(Dense + Reshape)
z((z)) --> C
z--> D2(Dense + Reshape)
D2 --> Convs(4 x Deconv 1D)
Convs --> C2(Concat)
D --> C2(Concat)
C2 --> z'((z'))
style Convs fill:#daa
style D fill:#ada
style D2 fill:#ada
style C fill:#dda
style C2 fill:#dda
</div><blockquote>
<p>The fully connected part contains information about the protein features while the deconvolutional part adds information about the location these features. Doing both rather than just one improves test reconstruction accuracy by 1%.</p>
</blockquote>
<p>The Decoder Architecture has the following architecture:</p>
<div class="mermaid">graph LR
x(x) --> W1
z'(z') --> W1(WaveNet 1)
W1 --> W2(WaveNet 2)
W2 --> W3(WaveNet 3)
z' --> W2
z' --> W3
W1 --> plus
W2 --> plus
W3 --> plus(+)
plus --> L(1x1 + Softmax)
L --> x'(x')
style W1 fill:#aad
style W2 fill:#aad
style W3 fill:#aad
style plus fill:#fff
style L fill:#ada
</div><p>where each <code>WaveNet</code> block is</p>
<div class="mermaid">graph LR
subgraph WaveNet
A
C
plus
f
c
end
x(x) --> C(2 x Causal Conv)
z'(z') --> A(1 x 1)
C --> plus(+)
A --> plus
plus --> f("function <br>x*sigmoid(x)")
f --> c(1 x 1)
c --> x2(Residual Connection)
c --> n(Next WaveNet Block)
style C fill:#daa
style A fill:#ada
style c fill:#ada
style plus fill:#fff
style f fill:#dda
style n fill:#aad
style x2 fill:#fff
</div><p>All the residual connections are added together at the <code>+</code> Node. These residual connections reduce the vanishing gradient problem , making the training easier <sup class="footnote-ref"><a href="#fn30" id="fnref30">[30]</a></sup>. Here, only three WaveNet blocks are represented, but there could be a chain of <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.69444em;vertical-align:0em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.03148em;">k</span></span></span></span> WaveNet blocks. Causal convolutions are convolutions that map an input sequence <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">s</span></span></span></span> to an output sequence <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>s</mi><mo mathvariant="normal">′</mo></msup></mrow><annotation encoding="application/x-tex">s&#x27;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.751892em;"></span><span class="strut bottom" style="height:0.751892em;vertical-align:0em;"></span><span class="base"><span class="mord"><span class="mord mathit">s</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span> of same size. Each element in the output sequence only depends upon the corresponding previous elements in the input sequence. Each causal convolution is dilated with a dilation factor doubled each time, so that the receptive field of the autoregressive model grows exponentially with the number of WaveNet blocks. After 3 blocks, the receptive field is 32 amino-acids.</p>
<h3 class="mume-header" id="hyperparameters-and-reconstruction-procedure">Hyperparameters and Reconstruction procedure</h3>

<p>All convolutional layers have a kernel size of 2 and are followed by batch normalization, a very effective technique to improve reconstruction accuracy while dramatically increasing training speed <sup class="footnote-ref"><a href="#fn31" id="fnref31">[31]</a></sup>. When not specified, the layers are followed by a PReLU Activation Layer (Parametric Rectified Linear Unit), which yielded the best reconstruction performance (tested against  ELU, ReLU, tanh) <sup class="footnote-ref"><a href="#fn32" id="fnref32">[32]</a></sup>.</p>
<p>We train the ProtCNN network as a typical VAE network, with a loss composed of a KL-divergence term and a cross-entropy term. The loss is minimized using the Adam optimizer<sup class="footnote-ref"><a href="#fn30" id="fnref30:1">[30:1]</a></sup> with default parameters for 50 epochs.</p>
<p>The generation of a one-hot encoded protein from a latent vector z and a conditions vector c is done with the following algorithm:</p>
<pre class="language-text">x = array of zeros with shape (prot_size, 21)
for i=1..prot_size do
p &lt;- Decoder([x, z, c])[i, :]  # Amino-acid probabilities for position i
x[i, argmax(p)] &lt;- 1  # The most probable amino-acid is set at position i
</pre>
<h2 class="mume-header" id="model-analysis">Model Analysis</h2>

<h3 class="mume-header" id="accuracy-results">Accuracy Results</h3>

<p>When trained of the Luciferase-like (LL) protein dataset with a random train/test split, the model predicts the next amino-acid in a sequence with a 77% test accuracy. However, since some sequences in the dataset are very close from one another, we can build a test set where the maximum homology between a protein from the train set and a protein from the test set is 50%. In that case, the model predicts the next amino-acid in a sequence with a 62% accuracy. Trying to reconstruct proteins that are not in the LL domain led to accuracies close to 12%, which means that the model learns features that are specific to the LL domain.</p>
<h3 class="mume-header" id="distribution-of-amino-acids-and-n-grams">Distribution of Amino-Acids and n-grams</h3>

<p>In proteins, amino-acids are not equally distributed and some appear more often than others. We expect the neural network to generate sequences with the same amino-acid frequencies that in the training dataset. Moreover, groups of three amino-acids (called 3-grams or 3-mers) also do not occur with uniform probability in the dataset. We can therefore compare the frequencies of occurrence of the 8397 unique 3-mers in the training set and in the sequences generated by sampling the latent space.</p>
<p>Here are the results:<br>
<img src="/projects/pasteur_images/aa_frq.png"></p>
<blockquote>
<p>Left: Distribution of amino-acid frequencies, for the training dataset (A) and the generated sequences (B).<br>
Right: Scatterplot of the probabilities of occurence of the 3-mers (x-axis: training set, y-axis: generated sequences)</p>
</blockquote>
<p>As we can see, the generative network can indeed roughly reproduce the distribution of amino-acids, but it tends to predict abundant amino-acids such as Alanine (A) too frequently and rare amino-acids such as Cysteine <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.07153em;">C</span></span></span></span> too rarely. This problem of imbalanced classes is standard in classification problems <sup class="footnote-ref"><a href="#fn33" id="fnref33">[33]</a></sup> and can be solved by a weighted loss associated to each amino-acid, which might be considered for future work.<br>
While the 3-gram frequencies of the generated sequences correlate nicely with the training set, we can observe the same tendency to produce abundant 3-grams more often than expected.</p>
<h3 class="mume-header" id="latent-space-organization">Latent Space Organization</h3>

<p>During training, the KL divergence term encourages the encoded data in the latent space to follow a normal distribution <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mi mathvariant="script">N</mi></mrow><mo>(</mo><mn>0</mn><mo separator="true">,</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">\mathscr{N}(0,1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mord"><span class="mord mathscr" style="margin-right:0.3525em;">N</span></span><span class="mopen">(</span><span class="mord">0</span><span class="mpunct">,</span><span class="mord rule" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span>.  The true distribution is however not normal and some regions of the latent space are left &quot;empty&quot;, far from the reconstructed proteins. As a result, when sampling the latent space randomly, only 30% of the generated sequences are identified as part of the bacterial Luciferase like PFAM family, where the identification is made with a Hidden Markov Model with a E-value score filter of 0.1.</p>
<p>When training the latent space without conditioning, the latent space encoded physical properties of the protein, the principal component being strongly correlated with the protein size for instance. With conditioning, the correlation between the latent space variables and the properties passed as a conditioning vector is strongly reduced.</p>
<p>The latent space tends to group together proteins than belong to the same family. Indeed, we identified 24 relatively balanced non-overlapping Interpro families containing more than 100 samples, for a total of 50 000 proteins, inside the Luciferase domain. A simple multi-class logistic regression model trained on top of the latent representation of these 50 000 proteins allows to classify proteins with a 92.7% accuracy. This shows that the different families tend to be well separated in the latent space.</p>
<h3 class="mume-header" id="amino-acid-relatedness">Amino Acid Relatedness</h3>

<p>Along with the preservation of the statistical distribution of the dataset, a natural question is whether the network is able to learn sensible biological information about proteins. One way to assess this is to check whether the network captures the notion of amino-acid interchangeability: amino acids having similar properties (charge, polarity, hydrophobicity, weight...) are more likely to preserve the activity and folding of a protein when swapped in its sequence, as quantified by the Blosum 62 matrix.<br>
When the ProtCNN network reconstructs a protein, it outputs for each protein and each sequence position a set of 21 probabilities, one for each amino-acid. Close amino-acids are likely to have similar probabilities in these sets of probabilities. That is why we can compute for two amino acids <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">a</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.69444em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">b</span></span></span></span>, the correlation coefficient of the probabilities associated to <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">a</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.69444em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">b</span></span></span></span> across all positions and all proteins.</p>
<p>This correlation coefficient is high if <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">a</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.69444em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">b</span></span></span></span> are highly swappable and low otherwise. The values of these coefficient seem to be have a non-linear (second-order polynomial) relation with the Blosum Matrix. Correcting this non-linear effect give us a new Blosum 62 matrix whose values are comparable to the original Blosum 62 Matrix.</p>
<p>We visualize these generated values with a scatterplot, to check the relationship between the new blosum values and the original Blosum 62 values,  and a heatmap, where hot colors indicate high interchangeability and cold colors low interchangeability.</p>
<img src="/projects/pasteur_images/scatterplusblosum.png">
> Left: Scatterplot of the generated blosum values versus the original Blosum 62 values for all pairs of amino-acids.
> Right: HeatMap of Blosum Values. Lower Diagonal: Original Blosum 62 Matrix, Upper Diagonal: Blosum Matrix generated with the correlation coefficients. The amino-acids in the x and y axis are represented by their letter and are ordered so that amino-acids with similar properties are close to each other.
<p>We can see a strong correlation between the original values and the generated values. The upper diagonal (Generated Blosum) of the heatmap has the same general structure as the lower diagonal (Original Blosum).</p>
<p>Our model therefore understands very well the similarities and dissimilarities of amino-acids, with the notable exception of W and Y that are not predicted as easily swappable by our model although identified as such by the Blosum 62 Matrix.</p>
<h3 class="mume-header" id="conditioning">Conditioning</h3>

<p>Conditioning consists in providing additional information to the encoder and the decoder, which allows to control the high-level features of the generated samples. In our case, the high-level features are physical properties of the proteins: the length, charge, iso-electric point, molar extinction coefficient and probability of expression in inclusion bodies, which is a measure of solubility. Interestingly, providing these information enabled a 2% gain in reconstruction accuracy.</p>
<p>To test the ability of our model to generate samples with desired properties, we consider a set of fixed properties and let one condition vary linearly from -2 to +2 (quantities are standard scaled). We then sample 32 points from the latent space with these conditions and generate the corresponding proteins, for which we then re-calculate the physical properties to check if the conditioning worked. It is worth noting than we cannot condition on very correlated variables (such as length and molecular weight) independently.<br>
Here, we show an example of a conditioning graph where we condition upon solubility. The green lines represent the value provided in the conditioning vector:<br>
<img src="/projects/pasteur_images/conditionning_solubility.png"></p>
<p>We can see that the physical properties of the reconstructed proteins are well conserved on average, but there is a lot of variance in the results.</p>
<p>Next, we chose a specific protein (a F420-dependent glucose-6-phosphate dehydrogenase) and generated variants of this proteins by conditioning upon increasing values of solubility (decreasing values of insolubility). Although conditioning did not work perfectly, it produced significant results on the solubility parameter without affecting the other physical properties.</p>
<img src="/projects/pasteur_images/conditionning2.png">
>  Blue violins: Distribution over the whole dataset. The following violins are obtained by generating 100 variants of the input protein, with no conditioning (Green),  conditioning with insolubility of 0.39 (Red), and conditioning with solubility of 0.22 (Purple). The corresponding green, red and purple lines show the theoretical values on expectation.
<h3 class="mume-header" id="secondary-structure-conservation">Secondary Structure Conservation</h3>

<p>The protein secondary structure is the 3D organization of local segments of amino-acids in the protein sequence. The two most common secondary structural elements are the alpha helix, and the beta sheet (formed of beta strands).<br>
Below is a simplified representation of those two elements.</p>
<img src="/projects/pasteur_images/alpha_beta.png">
<p>Secondary structure elements typically spontaneously form as an intermediate before the protein folds into its native 3D structure (tertiary structure).</p>
<p>In this section, we want to check whether our generative model can make functional variants of a protein, for which it is needed that the variants have the same structure as the original protein and in particular the secondary structure. We will especially focus on a protein called LuxA and its cluster of closely related proteins.</p>
<p>Computing the secondary structure of a protein is a simpler problem than computing the whole 3D structure but is still very challenging. Most softwares need a multiple sequence alignment from a protein family to compute the secondary structure of all the proteins in the alignment, assuming that they all have the same spatial organization. However we cannot use this technique to compute the secondary structure of our variants because the software will see our mutations as noise and will output an averaged secondary structure close to our original protein in any case. That is why we use the PSIPRED software <sup class="footnote-ref"><a href="#fn34" id="fnref34">[34]</a></sup> for computing secondary structures for single proteins, which has the unavoidable drawback of having a lot of noise in its output. PSIPRED gives, for each amino-acid in a sequence, the probability that this amino-acid is part of an helix (<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>p</mi><mi>H</mi></msub></mrow><annotation encoding="application/x-tex">p_H</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="base"><span class="mord"><span class="mord mathit">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight" style="margin-right:0.08125em;">H</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span></span></span></span>), a beta strand (<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>p</mi><mi>E</mi></msub></mrow><annotation encoding="application/x-tex">p_E</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="base"><span class="mord"><span class="mord mathit">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight" style="margin-right:0.05764em;">E</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span></span></span></span>) or a coil (<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>p</mi><mi>C</mi></msub></mrow><annotation encoding="application/x-tex">p_C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="base"><span class="mord"><span class="mord mathit">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight" style="margin-right:0.07153em;">C</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span></span></span></span>), with <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>p</mi><mi>C</mi></msub><mo>+</mo><msub><mi>p</mi><mi>H</mi></msub><mo>+</mo><msub><mi>p</mi><mi>E</mi></msub><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">p_C + p_H + p_E = 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.64444em;"></span><span class="strut bottom" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="base"><span class="mord"><span class="mord mathit">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight" style="margin-right:0.07153em;">C</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span><span class="mord rule" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mord rule" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathit">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight" style="margin-right:0.08125em;">H</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span><span class="mord rule" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mord rule" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathit">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight" style="margin-right:0.05764em;">E</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mord">1</span></span></span></span>, along with the most probable secondary structure element for this amino-acid. From now on, we say that a sequence S= 'CCCCHHHHEECCC...' is the secondary structure of a protein <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="base"><span class="mord mathit">p</span></span></span></span> if each  character in S represents the structure of the corresponding amino-acid in the protein sequence, as computed by PSIPRED.</p>
<p>Here is a colored view of the secondary structure of the proteins in LuxA's cluster. Each row corresponds to a protein in this cluster, and each column to a position in the sequence alignment. Proteins have been aligned and re-ordered to improve legibility.</p>
<img src="/projects/pasteur_images/luxa_cluster.png">
<p>Changing random amino-acids at random places often spoils the secondary structure of a protein as it can remove essential residues interactions at some critical sites; we would expect our ProtCNN model to be able to generate distant variants of a protein while keeping a globally consistent protein structure.</p>
<p>To that extent, we consider the following metrics for estimating the distance of a variant <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">s</span></span></span></span> to a protein cluster <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.07153em;">C</span></span></span></span> :</p>
<ul>
<li><strong>Minimum Alignment Distance</strong> between <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">s</span></span></span></span> and the proteins in <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.07153em;">C</span></span></span></span> (<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>d</mi><mrow><mi>m</mi><mi>i</mi><mi>n</mi></mrow></msub></mrow><annotation encoding="application/x-tex">d_{min}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="base"><span class="mord"><span class="mord mathit">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathit mtight">m</span><span class="mord mathit mtight">i</span><span class="mord mathit mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span></span></span></span>).</li>
<li><strong>Mean of all Alignment Distances</strong> between <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">s</span></span></span></span> and the proteins in <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.07153em;">C</span></span></span></span> (<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>d</mi><mrow><mi>m</mi><mi>e</mi><mi>a</mi><mi>n</mi></mrow></msub></mrow><annotation encoding="application/x-tex">d_{mean}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="base"><span class="mord"><span class="mord mathit">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathit mtight">m</span><span class="mord mathit mtight">e</span><span class="mord mathit mtight">a</span><span class="mord mathit mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span></span></span></span>).</li>
<li><strong>Mean Blosum Distance</strong> between <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">s</span></span></span></span> and the proteins in <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.07153em;">C</span></span></span></span> (<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>d</mi><mrow><mi>b</mi><mi>l</mi><mi>o</mi><mi>s</mi><mi>u</mi><mi>m</mi></mrow></msub></mrow><annotation encoding="application/x-tex">d_{blosum}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="base"><span class="mord"><span class="mord mathit">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathit mtight">b</span><span class="mord mathit mtight" style="margin-right:0.01968em;">l</span><span class="mord mathit mtight">o</span><span class="mord mathit mtight">s</span><span class="mord mathit mtight">u</span><span class="mord mathit mtight">m</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span></span></span></span>)</li>
</ul>
<p>For the fitness metric, we use the <strong>Negative Log Likelihood of Secondary Structure Probabilities</strong>, which quantifies the distance of a secondary structure to the distribution of secondary structures in a cluster. In the alignment of secondary structures, the structure elements (C, H, and E) occur at position <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.65952em;"></span><span class="strut bottom" style="height:0.65952em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">i</span></span></span></span> with frequencies <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>p</mi><mi>i</mi></msub><mo>(</mo><mi>C</mi><mo>)</mo><mo separator="true">,</mo><msub><mi>p</mi><mi>i</mi></msub><mo>(</mo><mi>H</mi><mo>)</mo><mo separator="true">,</mo><msub><mi>p</mi><mi>i</mi></msub><mo>(</mo><mi>E</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">p_i(C), p_i(H), p_i(E)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mord"><span class="mord mathit">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.07153em;">C</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mord rule" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathit">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.08125em;">H</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mord rule" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathit">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.05764em;">E</span><span class="mclose">)</span></span></span></span>. The probability of a secondary structure <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">ss</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">s</span><span class="mord mathit">s</span></span></span></span> with respect to this distribution is <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mo>∏</mo><mi>i</mi></msub><msub><mi>p</mi><mi>i</mi></msub><mo>(</mo><mi>s</mi><msub><mi>s</mi><mi>i</mi></msub><mo>)</mo></mrow><annotation encoding="application/x-tex">\prod_i p_i(ss_i)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1.0497100000000001em;vertical-align:-0.29971000000000003em;"></span><span class="base"><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∏</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.16195399999999993em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29971000000000003em;"></span></span></span></span></span><span class="mord rule" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathit">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span><span class="mopen">(</span><span class="mord mathit">s</span><span class="mord"><span class="mord mathit">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span><span class="mclose">)</span></span></span></span>, that is why we consider the fitness distance <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>d</mi><mrow><mi>N</mi><mi>L</mi><mi>L</mi></mrow></msub><mo>(</mo><mi>s</mi><mi>s</mi><mo>)</mo><mo>=</mo><mo>−</mo><msub><mo>∑</mo><mi>i</mi></msub><mi>l</mi><mi>o</mi><mi>g</mi><mo>(</mo><msub><mi>p</mi><mi>i</mi></msub><mo>(</mo><mi>s</mi><msub><mi>s</mi><mi>i</mi></msub><mo>)</mo><mo>)</mo></mrow><annotation encoding="application/x-tex">d_{NLL}(ss) = - \sum_i log(p_i(ss_i))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1.0497100000000001em;vertical-align:-0.29971000000000003em;"></span><span class="base"><span class="mord"><span class="mord mathit">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathit mtight" style="margin-right:0.10903em;">N</span><span class="mord mathit mtight">L</span><span class="mord mathit mtight">L</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span><span class="mopen">(</span><span class="mord mathit">s</span><span class="mord mathit">s</span><span class="mclose">)</span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mord">−</span><span class="mord rule" style="margin-right:0.16666666666666666em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.16195399999999993em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29971000000000003em;"></span></span></span></span></span><span class="mord rule" style="margin-right:0.16666666666666666em;"></span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mord mathit">o</span><span class="mord mathit" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord"><span class="mord mathit">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span><span class="mopen">(</span><span class="mord mathit">s</span><span class="mord"><span class="mord mathit">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span><span class="mclose">)</span><span class="mclose">)</span></span></span></span>. The lower the distance, the closer the secondary structure to the original cluster is.</p>
<p>We will test the performance of our generative model against four baseline model, that computes variants of proteins in LuxA's cluster:</p>
<ul>
<li><strong>Cluster Model</strong>: This model simply outputs a random protein from LuxA's cluster. This should provide a &quot;groundtruth&quot; model.</li>
<li><strong>Simple Stats Model</strong>: This model generates a variant of a protein by taking random positions in a protein sequence and by making a mutations at those positions, following the global amino-acid occurrence frequency in the cluster.</li>
<li><strong>MSA Stats Model</strong>: This model takes as input a sequence alignment of the cluster, computes the amino-acid frequencies for all positions and samples this distribution.</li>
<li><strong>Thermal Blosum Model</strong>: This model makes mutation for amino-acids based on their blosum scores, considered as energies in a boltzmann sampling: As a result, the most interchangeable amino-acids are mutated first.</li>
</ul>
<p>The ProtCNN model exploits information from the LuxA cluster by interpolating randomly the latent representation of the cluster's proteins <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>z</mi><mn>1</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><msub><mi>z</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">z_1, ... z_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="base"><span class="mord"><span class="mord mathit" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.04398em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span><span class="mpunct">,</span><span class="mord rule" style="margin-right:0.16666666666666666em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mord"><span class="mord mathit" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.04398em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span></span></span></span>, with the following algorithm:</p>
<ul>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">i=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.65952em;"></span><span class="strut bottom" style="height:0.65952em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">i</span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mord">0</span></span></span></span></li>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>y</mi><mn>0</mn></msub><mo>=</mo><mfrac><mrow><mn>1</mn></mrow><mrow><mi>n</mi></mrow></mfrac><msubsup><mo>∑</mo><mi>i</mi><mi>n</mi></msubsup><msub><mi>z</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">y_0 = \frac{1}{n} \sum_i^n z_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.845108em;"></span><span class="strut bottom" style="height:1.190108em;vertical-align:-0.345em;"></span><span class="base"><span class="mord"><span class="mord mathit" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathit mtight">n</span></span></span></span><span style="top:-3.15em;"><span class="pstrut" style="height:3em;"></span><span class="stretchy" style="height:0.2em;"><svg width="400em" height="0.2em" viewBox="0 0 400000 200" preserveAspectRatio="xMinYMin slice"><path d="M0 80H400000 v40H0z M0 80H400000 v40H0z"></path></svg></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord rule" style="margin-right:0.16666666666666666em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.804292em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight">i</span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29971000000000003em;"></span></span></span></span></span><span class="mord rule" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathit" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.04398em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span></span></span></span></li>
<li>Repeat:
<ul>
<li>Choose a random latent protein <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>z</mi><mi>l</mi></msub></mrow><annotation encoding="application/x-tex">z_l</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="base"><span class="mord"><span class="mord mathit" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.04398em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight" style="margin-right:0.01968em;">l</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span></span></span></span></li>
<li>Sample  <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>r</mi><mi>i</mi></msub><mo>∼</mo><mi>U</mi><mo>(</mo><mo>[</mo><mn>0</mn><mo separator="true">,</mo><mn>1</mn><mo>]</mo><mo>)</mo></mrow><annotation encoding="application/x-tex">r_i \sim U([0,1])</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mord"><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∼</span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mord mathit" style="margin-right:0.10903em;">U</span><span class="mopen">(</span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mord rule" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mclose">)</span></span></span></span></li>
<li>Compute <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>y</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>=</mo><msub><mi>r</mi><mi>i</mi></msub><msub><mi>y</mi><mi>i</mi></msub><mo>+</mo><mo>(</mo><mn>1</mn><mo>−</mo><msub><mi>r</mi><mi>i</mi></msub><mo>)</mo><msub><mi>z</mi><mi>l</mi></msub></mrow><annotation encoding="application/x-tex">y_{i+1} = r_i y_i + (1-r_i) z_l</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mord"><span class="mord mathit" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathit mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"></span></span></span></span></span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span><span class="mord"><span class="mord mathit" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span><span class="mord rule" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mord rule" style="margin-right:0.2222222222222222em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mord rule" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mord rule" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span><span class="mclose">)</span><span class="mord"><span class="mord mathit" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.04398em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight" style="margin-right:0.01968em;">l</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span></span></span></span></li>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mo>=</mo><mi>i</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">i = i+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.65952em;"></span><span class="strut bottom" style="height:0.74285em;vertical-align:-0.08333em;"></span><span class="base"><span class="mord mathit">i</span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mord mathit">i</span><span class="mord rule" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mord rule" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span></span></span></span></li>
</ul>
</li>
</ul>
<p>This proved to be more efficient than gaussian sampling around a single protein as it takes advantage of the latent representation of a whole cluster.</p>
<p>We generate variants for each of these generative models and plot them on a ScatterPlot, where the <em>x</em> axis is a protein distance metric and the <em>y</em> is the secondary structure distance metric (fitness metric).</p>
<img src="/projects/pasteur_images/plotsfinal1seq-blos.png">
> Scatter Plot of Variants generated with the ProtCNN (latent interpolation) and the baseline models. The Negative Log Likelihood is used to assess the secondary structure conservation. Sequence metrics: $d_{mean}$ (Left) and $d_{blosum}$ (Right).
<p>We can see that the Msa Stats Model provides variants that have a worse  Secondary Structure Score than the Cluster on average. The performance of the Thermal Blosum Model and the ProtCNN model are roughly the same for the <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>d</mi><mrow><mi>m</mi><mi>e</mi><mi>a</mi><mi>n</mi></mrow></msub></mrow><annotation encoding="application/x-tex">d_{mean}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="base"><span class="mord"><span class="mord mathit">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathit mtight">m</span><span class="mord mathit mtight">e</span><span class="mord mathit mtight">a</span><span class="mord mathit mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span></span></span></span> distance metric, and the Thermal Blosum Model  is slightly worse  with the <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>d</mi><mrow><mi>b</mi><mi>l</mi><mi>o</mi><mi>s</mi><mi>u</mi><mi>m</mi></mrow></msub></mrow><annotation encoding="application/x-tex">d_{blosum}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="base"><span class="mord"><span class="mord mathit">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathit mtight">b</span><span class="mord mathit mtight" style="margin-right:0.01968em;">l</span><span class="mord mathit mtight">o</span><span class="mord mathit mtight">s</span><span class="mord mathit mtight">u</span><span class="mord mathit mtight">m</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span></span></span></span> distance metric because it tends to select mutations that account for a smaller Blosum Distance.</p>
<p>Here is the same scatter plot using the <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>d</mi><mrow><mi>m</mi><mi>i</mi><mi>n</mi></mrow></msub></mrow><annotation encoding="application/x-tex">d_{min}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="base"><span class="mord"><span class="mord mathit">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathit mtight">m</span><span class="mord mathit mtight">i</span><span class="mord mathit mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span></span></span></span> distance:</p>
<img src="/projects/pasteur_images/plot_min_nll.png">
<p>The Cluster Variants have a Min Cluster Sequence Alignment Distance of 0 as expected. For more than 20 mutations, the Simple Stats model provides a Secondary Structure NLL always too high compared to the cluster; The ProtCNN model seems to be quite good for this metric, since it generates a lot of variants that have between 0 and 80 mutations and that have a low secondary structure score.</p>
<h4 class="mume-header" id="limitations">Limitations</h4>

<ul>
<li>Although the dataset of Luciferase share a lot of secondary structure properties, computations made with PSIPRED show a lot of variance in those secondary structures. It could be that they truly have different secondary structures and in that case the model could encode secondary structure information in the latent space, making a sampling approach irrelevant for secondary structure conservation. This is however unlikely.</li>
<li>The PSIPRED predictions are noisy and from the results above, it is difficult to assess if a generative model is really better than the other. We tried to reduce this noise with the Negative Log Likelihood metrics, but it is hard to know if this is enough. At least, it shows that random mutations spoil the Secondary Structure of the protein.</li>
<li>Even if our model scores well according to this metric, it doesn't mean that the tertiary structure of a synthetized variant will be the same as in the LuxA cluster and that this variant will be functional.</li>
</ul>
<h3 class="mume-header" id="contact-map">Contact Map</h3>

<p>When the protein acquires its native folding, some amino-acids are in contact and therefore interact strongly with one another. This pattern is reflected in the covariation of sites in the sequence of the protein. Given an alignment of multiple sequences, it has been proposed to consider correlations between sites as indicators of contact in the native folding.</p>
<img src="/projects/pasteur_images/covary_small.gif">
<blockquote>
<p>Two positions in the sequence that are in contact are likely to show co-evolution across a protein family.</p>
</blockquote>
<p>However, correlations might appear from biased sampling as well as from indirect coupling between sites. That is why looking at the correlations only give poor results. More recent studies take these effects into account, giving relatively accurate contact prediction tools, including Direct Coupling Analysis <sup class="footnote-ref"><a href="#fn35" id="fnref35">[35]</a></sup>, Pseudo Likelihood Methods <sup class="footnote-ref"><a href="#fn36" id="fnref36">[36]</a></sup> and even Deep-Neural network based methods <sup class="footnote-ref"><a href="#fn37" id="fnref37">[37]</a></sup>.<br>
These methods output what is called a contact map, which is a two-dimensional representation of the three-dimensional protein structure showing which residues are in contact for a specified distance cutoff. The level of gray shows the probability of two residues being in contact.</p>
<img src="/projects/pasteur_images/contact_map_small.gif">
> The example above shows a contact (yellow dashed line) between two strands of a protein structure, on the right. The same contact is also shown on the contact map as a yellow-filled circle. Notice the rainbow color on both the structure and contact map: the blue region is in contact with the green region.
<p>We submitted an alignment of our Luciferase-Like dataset to <a href="http://gremlin.bakerlab.org/">GREMLIN</a>, an online software for the computation of contact maps from multiple sequence alignment; The result is shown below. For comparison, we provide a contact map for the LuxA protein in the dataset, computed from physical measures.<br>
<img src="/projects/pasteur_images/lux_cluster_msa_cmap2.png"></p>
<blockquote>
<p>Left: Contact Map calculated by Gremlin with the multiple sequence alignment. Right: Contact Map of LuxA determined through X-ray crystallography.</p>
</blockquote>
<p>A qualitative metric for our model is to test whether the generated sequences have the desired residues correlations, which should be seen in the contact map calculated from their alignment. One approach is to reconstruct proteins from the dataset, align them, and compute the contact map through residues correlations. This method is however biased, because the good overall reconstruction accuracy will result in the reconstructed sequences having correlations similar to the input dataset.</p>
<p>We therefore generate variants of a single protein LuxA. The generated variants should theoretically reflect the correlation of the dataset since residues in contact could not be changed independently without altering the structure of the protein.</p>
<p>To this purpose, we sample the latent space around the latent representation of LuxA, according to two methods: gaussian sampling and ellipsoid sampling. The gaussian sampling consists in adding a gaussian noise to the latent representation of LuxA.<br>
The ellipsoid sampling tries to take into account the latent structure of LuxA's cluster. It considers that the directions in which there are the most variance in this latent structure are interesting directions to explore when sampling the latent space.<br>
The detailed algorithm is:</p>
<ul>
<li>Compute the latent representation of each protein in LuxA's cluster50, which is the latent cluster.<br>
Compute a PCA with <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">n</span></span></span></span> components of the latent cluster.<br>
The PCA gives n vectors <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>z</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">z_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="base"><span class="mord"><span class="mord mathit" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.04398em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span></span></span></span>, ... <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>z</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">z_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="base"><span class="mord"><span class="mord mathit" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.04398em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span></span></span></span>, where we consider that the norm of each vector is equal to the standard deviation of the latent cluster according to the vector's direction.</li>
<li>compute <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>z</mi><mrow><mi>m</mi><mi>e</mi><mi>a</mi><mi>n</mi></mrow></msub></mrow><annotation encoding="application/x-tex">z_{mean}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="base"><span class="mord"><span class="mord mathit" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.04398em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathit mtight">m</span><span class="mord mathit mtight">e</span><span class="mord mathit mtight">a</span><span class="mord mathit mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span></span></span></span> the mean point of the latent cluster</li>
<li>Sample the distribution <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><msub><mi>z</mi><mrow><mi>m</mi><mi>e</mi><mi>a</mi><mi>n</mi></mrow></msub><mo>+</mo><msubsup><mo>∑</mo><mi>i</mi><mi>n</mi></msubsup><msub><mi>r</mi><mi>i</mi></msub><msub><mi>z</mi><mi>i</mi></msub></mrow></mrow><annotation encoding="application/x-tex">{z_{mean} + \sum_i^n r_i z_i}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.804292em;"></span><span class="strut bottom" style="height:1.104002em;vertical-align:-0.29971000000000003em;"></span><span class="base"><span class="mord"><span class="mord"><span class="mord mathit" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.04398em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathit mtight">m</span><span class="mord mathit mtight">e</span><span class="mord mathit mtight">a</span><span class="mord mathit mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span><span class="mord rule" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mord rule" style="margin-right:0.2222222222222222em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.804292em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight">i</span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29971000000000003em;"></span></span></span></span></span><span class="mord rule" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span><span class="mord"><span class="mord mathit" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.04398em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span></span></span></span></span> where <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>r</mi><mi>i</mi></msub><mo>∼</mo><mrow><mi mathvariant="script">N</mi></mrow><mo>(</mo><mn>0</mn><mo separator="true">,</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">r_i \sim \mathscr{N}(0,1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mord"><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∼</span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mord mathscr" style="margin-right:0.3525em;">N</span></span><span class="mopen">(</span><span class="mord">0</span><span class="mpunct">,</span><span class="mord rule" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span></li>
</ul>
<p>We generated 10000 samples with the two methods, which give the following results:<br>
<img src="/projects/pasteur_images/sphere_ellipsoide_cmqp.png"></p>
<blockquote>
<p>Contact Map of aligned variants of a single protein (LuxA). Left: Gaussian sampling. Right: Ellipsoid Sampling</p>
</blockquote>
<p>For the gaussian methods, the results are disappointing: Apart from short-range correlations, there is too much noise in the correlation data to display contact patterns.  The ellipsoid pattern are a little more convincing and reflect mostly long-range interaction in the first part of the protein sequence and short-range interactions in the second half of the sequence, which are less homogeneous than in the gaussian sampling.</p>
<p>It could mean than the generated sequences do not reproduce the correlation patterns of the input dataset. This correlations are however hidden in a multiple sequence alignment and are probably too hard to find for our model. It could also be that the correlation signal in the generated variants is mixed with a lot of side correlations which spoils the contact map analysis.</p>
<p>This method might hold some promises but is yet far from producing the expected results.</p>
<h2 class="mume-header" id="experimental-results">Experimental Results</h2>

<p>Finally, we sought to experimentally validate the ability of ProtCNN to generate functional protein variants. To this end we generated variants of the <em>luxA</em> gene from <em>Photorhabdus luminescens</em>. Protein variants were generated by ProtCNN by randomly sampling the latent space around the representation of <em>luxA</em>. A set of 23 variants more or less distant from the LuxA primary sequence were chosen spanning between 11 and 34 amino acid differences. The variants are chosen so that they have a minimum pairwise distance of 10 and that they are no closer to another protein of the training dataset. DNA sequences encoding these proteins were synthesized and introduced in E. Coli strains, while ensuring that they would all be expressed at the same level. Luminescence could be measured for 17/23 (74%) of the variants, with the most distant variants still producing light carrying 27 mutations.</p>
<p>However, these experimental results are to be taken carefully because of many reasons :</p>
<ul>
<li><strong>Dataset Structure</strong>: the proportion of luciferase-like proteins in the dataset that effectively produce light is unknown, so the latent space could encode high-level features that do not reflect the light-emitting property.</li>
<li><strong>Absence of Control Model</strong>: It could be that randomly mutating 5% of positions in a protein still allows to conserve the light-emitting property. This is however very unlikely and a mutation rate of 5% is often believed to remove the chemical property of a protein. This hypothesis would still need to be tested however and switching close amino-acids with respect to the blosum matrix could perhaps allow to generate functional variants with a mutation rate as high as 5%.</li>
<li><strong>Cost of DNA synthetizing</strong>: Since synthetizing DNA variants is very expensive, this experiment can be conducted with only a few variants, which explains why no control model has been used.</li>
</ul>
<h1 class="mume-header" id="conclusion">Conclusion</h1>

<p>Measuring the quality of generative models is quite hard because computing the true distribution of the input dataset is generally intractable. Lattice Proteins, which are highly simplified models of proteins, offer a nice framework in which generative models can be evaluated through a fitness metric that reflects the folding quality of a generated protein inside a given structure. Basic Variational Auto Encoders outperform sequence alignment-based methods and bio-inspired methods according to this fitness metric. However, a database of lattice proteins is artificially created through Monte Carlo sampling, and real protein databases are biased due to natural evolution.</p>
<p>Training a Conditional VAE with an autoregressive decoder on a dataset of luciferase-like proteins provides a compressed latent representation of those proteins, allowing to perform arithmetic operations on the latent space. This model is able to understand interchangeability properties between amino-acids and to modify high-level features of a protein with conditioning. We used a metric to evaluate whether ProtCNN was able to generate distant variants of a protein with a consistent secondary structure, compared to other statistical and blosum-based methods : The model showed good performance that ought to be taken carefully due to the inherent difficulty of computing the secondary structure of a protein. We also tried to check whether sites correlations in generated variants could reveal contacts in a protein, similarly to what is done with sequence alignment-based contact calculation methods, with no convincing results.</p>
<p>Overall, it is a highly challenging problem to assess whether a generative model produces functional variants of a protein with computational methods. Only experimental methods can really demonstrate functionality but the high cost of DNA synthetizing makes this approach impossible for the moment. However, the fact that our model scores relatively well on very different metrics is a sign that neural generative models offer promising tools to explore the protein space.</p>
<h3 class="mume-header" id="future-work">Future Work</h3>

<p>In the current model, random sampling of the latent space frequently yielded invalid proteins. Strategies to solve this problem have been proposed, in particular Adversarial Auto Encoders, that add a discriminator network to an autoencoder <sup class="footnote-ref"><a href="#fn28" id="fnref28:1">[28:1]</a></sup> <sup class="footnote-ref"><a href="#fn38" id="fnref38">[38]</a></sup>. The discriminator is trained to differentiate randomly sampled points in the latent space from the projection of actual data. The encoder is trained to fool this discriminator, thus forcing projections to occupy the while latent space and ensuring all points of the latent space can be decoded into valid samples.</p>
<p>Generative Adversarial Networks <sup class="footnote-ref"><a href="#fn39" id="fnref39">[39]</a></sup> <sup class="footnote-ref"><a href="#fn40" id="fnref40">[40]</a></sup> are a kind a generative model that generates realistic samples from noise, through a generator network trained to fool a discriminator network. While it remains a challenge to apply GANs to discrete data, recent studies proposed a strategy for that purpose <sup class="footnote-ref"><a href="#fn41" id="fnref41">[41]</a></sup>, that could be worth investigating.</p>
<p>Future work may focus on exploring the latent representation, scaling the model to bigger datasets, and provide more control over the generated sequences. Providing Structural information to the model might also be an interesting idea to generate variants with a fixed secondary structure.</p>
<hr class="footnotes-sep">
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p>Packer MS, Liu DR. Methods for the directed evolution of proteins. Nat Rev Genet. 2015;16: 379–394. <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn2" class="footnote-item"><p>Huang P-S, Boyken SE, Baker D. The coming of age of de novo protein design. Nature. 2016;537: 320–327. <a href="#fnref2" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn3" class="footnote-item"><p>Gainza P, Nisonoff HM, Donald BR. Algorithms for protein design. Curr Opin Struct Biol. 2016;39: 16–26. <a href="#fnref3" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn4" class="footnote-item"><p>Gómez-Bombarelli R, Duvenaud D, Hernández-Lobato JM, Aguilera-Iparraguirre J, Hirzel TD, Adams RP, et al. Automatic chemical design using a data-driven continuous representation of molecules, 2016. Available: <a href="http://arxiv.org/abs/1610.02415">http://arxiv.org/abs/1610.02415</a> <a href="#fnref4" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn5" class="footnote-item"><p>Segler MHS, Kogej T, Tyrchan C, Waller MP. Generating Focussed Molecule Libraries for Drug Discovery with Recurrent Neural Networks, 2017. Available: <a href="http://arxiv.org/abs/1701.01329">http://arxiv.org/abs/1701.01329</a> <a href="#fnref5" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn6" class="footnote-item"><p>Olivecrona M, Blaschke T, Engkvist O, Chen H. Molecular De Novo Design through Deep Reinforcement Learning, 2017. Available: <a href="http://arxiv.org/abs/1704.07555">http://arxiv.org/abs/1704.07555</a> <a href="#fnref6" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn7" class="footnote-item"><p>Biswas S.,  Kuznetsov G.,  Ogden P.,  Conway N.,  Adams R., Church G., Toward machine-guided design of proteins, bioRxiv 337154; Available:  <a href="https://doi.org/10.1101/337154">https://doi.org/10.1101/337154</a> <a href="#fnref7" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn8" class="footnote-item"><p>Kingma DP, Welling M.,  Auto-Encoding Variational Bayes,  2013. Available: <a href="http://arxiv.org/abs/1312.6114v10">http://arxiv.org/abs/1312.6114v10</a> <a href="#fnref8" class="footnote-backref">↩︎</a> <a href="#fnref8:1" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn9" class="footnote-item"><p>Rezende DJ, Mohamed S, Wierstra D. Stochastic Backpropagation and Approximate Inference in Deep Generative Models, 2014. Available: <a href="http://arxiv.org/abs/1401.4082">http://arxiv.org/abs/1401.4082</a> <a href="#fnref9" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn10" class="footnote-item"><p>Walker J, Doersch C, Gupta A, Hebert M.,  An Uncertain Future: Forecasting from Static Images using Variational Autoencoders, 2016. Available: <a href="http://arxiv.org/abs/1606.07873">http://arxiv.org/abs/1606.07873</a> <a href="#fnref10" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn11" class="footnote-item"><p>Kulkarni TD, Whitney W, Kohli P, Tenenbaum JB. Deep Convolutional Inverse Graphics Network, 2015. Available: <a href="http://arxiv.org/abs/1503.03167">http://arxiv.org/abs/1503.03167</a> <a href="#fnref11" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn12" class="footnote-item"><p>Dosovitskiy A, Springenberg JT, Tatarchenko M, Brox T. Learning to Generate Chairs, Tables and Cars with Convolutional Networks, 2014. Available: <a href="http://arxiv.org/abs/1411.5928">http://arxiv.org/abs/1411.5928</a> <a href="#fnref12" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn13" class="footnote-item"><p>Tim Salimans, Ian Goodfellow, Wojciech Zaremba, Vicki Cheung, Alec Radford, Xi Chen, Improved Techniques for Training GANs, 2016, Available : <a href="http://arxiv.org/abs/1606.03498">http://arxiv.org/abs/1606.03498</a> <a href="#fnref13" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn14" class="footnote-item"><p>Kristina Preuer, Philipp Renz, Thomas Unterthiner, Sepp Hochreiter, Günter Klambauer. Fréchet ChemblNet Distance: A metric for generative models for molecules, 2018, Available: <a href="http://arxiv.org/abs/1803.09518">http://arxiv.org/abs/1803.09518</a> <a href="#fnref14" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn15" class="footnote-item"><p>Henikoff, S., &amp; Henikoff, J. G. (1992). Amino acid substitution matrices from protein blocks. <em>Proceedings of the National Academy of Sciences of the United States of America</em>, <em>89</em>(22), 10915–10919. Available : <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC50453/">https://www.ncbi.nlm.nih.gov/pmc/articles/PMC50453/</a> <a href="#fnref15" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn16" class="footnote-item"><p>Jacquin, H., Gilson, A., Shakhnovich, E., Cocco, S., &amp; Monasson, R. (2016). Benchmarking Inverse Statistical Approaches for Protein Structure and Design with Exactly Solvable Models. <em>PLoS Computational Biology</em>, <em>12</em>(5), Available : <a href="http://doi.org/10.1371/journal.pcbi.1004889">http://doi.org/10.1371/journal.pcbi.1004889</a> <a href="#fnref16" class="footnote-backref">↩︎</a> <a href="#fnref16:1" class="footnote-backref">↩︎</a> <a href="#fnref16:2" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn17" class="footnote-item"><p>Jérôme Tubiana, Simona Cocco, Rémi Monasson,<br>
Learning protein constitutive motifs from sequence data, 2018, Available: <a href="https://arxiv.org/abs/1803.08718">https://arxiv.org/abs/1803.08718</a> <a href="#fnref17" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn18" class="footnote-item"><p>Miyazawa A, Jernigan R. Estimation of effective interresidue contact energies from protein crystal structures: quasi-chemical approximation. Macromolecules. 1985;18:534 Available: <a href="http://dx.doi.org/10.1021/ma00145a039">http://dx.doi.org/10.1021/ma00145a039</a> <a href="#fnref18" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn19" class="footnote-item"><p>Berezovsky IN, Zeldovich KB, Shakhnovich E. Positive and Negative Design in Stability and Thermal Adaptation of Natural Proteins. PLoS Comput Biol. 2007. 03;3(3):e52 10.1371/journal.pcbi.0030052 Available: <a href="http://dx.doi.org/10.1371/journal.pcbi.0030052">http://dx.doi.org/10.1371/journal.pcbi.0030052</a>) <a href="#fnref19" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn20" class="footnote-item"><p>Gulrajani I, Kumar K, Ahmed F, Taiga AA, Visin F, Vazquez D, et al. PixelVAE: A Latent Variable Model for Natural Images, 2016. Available: <a href="http://arxiv.org/abs/1611.05013">http://arxiv.org/abs/1611.05013</a> <a href="#fnref20" class="footnote-backref">↩︎</a> <a href="#fnref20:1" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn21" class="footnote-item"><p>Hochreiter S, Schmidhuber J. Long short-term memory. Neural Comput. 1997;9: 1735–1780. <a href="#fnref21" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn22" class="footnote-item"><p>Chung J, Gulcehre C, Cho K, Bengio Y. Empirical Evaluation of Gated Recurrent Neural Networks on Sequence Modeling, 2014. Available: <a href="http://arxiv.org/abs/1412.3555">http://arxiv.org/abs/1412.3555</a> <a href="#fnref22" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn23" class="footnote-item"><p>Shaojie Bai, J. Zico Kolter, Vladlen Koltun, An Empirical Evaluation of Generic Convolutional and Recurrent Networks for Sequence Modeling, 2018, Available: <a href="http://arxiv.org/abs/1803.01271">http://arxiv.org/abs/1803.01271</a> <a href="#fnref23" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn24" class="footnote-item"><p>van den Oord A, Dieleman S, Zen H, Simonyan K, Vinyals O, Graves A, et al. WaveNet: A Generative Model for Raw Audio, 2016. Available: <a href="http://arxiv.org/abs/1609.03499">http://arxiv.org/abs/1609.03499</a> <a href="#fnref24" class="footnote-backref">↩︎</a> <a href="#fnref24:1" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn25" class="footnote-item"><p>van den Oord A, Kalchbrenner N, Vinyals O, Espeholt L, Graves A, Kavukcuoglu K. Conditional Image Generation with PixelCNN Decoders, 2016. Available: <a href="http://arxiv.org/abs/1606.05328">http://arxiv.org/abs/1606.05328</a> <a href="#fnref25" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn26" class="footnote-item"><p>van den Oord A, Kalchbrenner N, Kavukcuoglu K. Pixel Recurrent Neural Networks, 2016. Available: <a href="http://arxiv.org/abs/1601.06759">http://arxiv.org/abs/1601.06759</a> <a href="#fnref26" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn27" class="footnote-item"><p>Gehring J, Auli M, Grangier D, Yarats D, Dauphin YN. Convolutional Sequence to Sequence Learning, 2017. Available: <a href="http://arxiv.org/abs/1705.03122">http://arxiv.org/abs/1705.03122</a> <a href="#fnref27" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn28" class="footnote-item"><p>Makhzani A, Frey B. PixelGAN Autoencoders, 2017. Available: <a href="http://arxiv.org/abs/1706.00531">http://arxiv.org/abs/1706.00531</a> <a href="#fnref28" class="footnote-backref">↩︎</a> <a href="#fnref28:1" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn29" class="footnote-item"><p>Rice P, Longden I, Bleasby A. EMBOSS: the European Molecular Biology Open Software Suite. Trends Genet. 2000;16: 276–277. <a href="#fnref29" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn30" class="footnote-item"><p>Kingma DP, Ba J. Adam: A Method for Stochastic Optimization, 2014. Available: <a href="http://arxiv.org/abs/1412.6980">http://arxiv.org/abs/1412.6980</a> <a href="#fnref30" class="footnote-backref">↩︎</a> <a href="#fnref30:1" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn31" class="footnote-item"><p>Sergey Ioffe, Christian Szegedy, Batch Normalization: Accelerating Deep Network Training by Reducing Internal Covariate Shift, 2015. Available: <a href="http://arxiv.org/abs/1502.03167">http://arxiv.org/abs/1502.03167</a> <a href="#fnref31" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn32" class="footnote-item"><p>He K, Zhang X, Ren S, Sun J. Delving Deep into Rectifiers: Surpassing Human-Level Performance on ImageNet Classification, 2015. Available: <a href="http://arxiv.org/abs/1502.01852">http://arxiv.org/abs/1502.01852</a> <a href="#fnref32" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn33" class="footnote-item"><p>He H, Garcia EA. Learning from Imbalanced Data. IEEE Trans Knowl Data Eng. 2009;21: 1263–1284. <a href="#fnref33" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn34" class="footnote-item"><p>Jones DT. Protein secondary structure prediction based on position-specific scoring matrices. J Mol Biol. 1999;292: 195–202. <a href="#fnref34" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn35" class="footnote-item"><p>Faruck Morcos,  Andrea Pagnani,  Bryan Lunt,  Arianna Bertolino,  Debora S. Marks,  Chris Sander,  Riccardo Zecchina,  José N. Onuchic,  Terence Hwa, and  Martin Weigt, Direct-coupling analysis of residue coevolution captures native contacts across many protein families, 2011. Available: <a href="https://doi.org/10.1073/pnas.1111471108">https://doi.org/10.1073/pnas.1111471108</a> <a href="#fnref35" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn36" class="footnote-item"><p>Magnus Ekeberg, Tuomo Hartonen, Erik Aurell, Fast pseudolikelihood maximization for direct-coupling analysis of protein structure from many homologous amino-acid sequences, 2014. Available: <a href="https://arxiv.org/abs/1401.4832">https://arxiv.org/abs/1401.4832</a> <a href="#fnref36" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn37" class="footnote-item"><p>David T Jones, Shaun M Kandathil, High precision in protein contact prediction using fully convolutional neural networks and minimal sequence features,  2018, Available: <a href="https://doi.org/10.1093/bioinformatics/bty341">https://doi.org/10.1093/bioinformatics/bty341</a> <a href="#fnref37" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn38" class="footnote-item"><p>Makhzani A, Shlens J, Jaitly N, Goodfellow I, Frey B. Adversarial Autoencoders, 2015. Available: <a href="http://arxiv.org/abs/1511.05644">http://arxiv.org/abs/1511.05644</a> <a href="#fnref38" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn39" class="footnote-item"><p>Goodfellow IJ, Pouget-Abadie J, Mirza M, Xu B, Warde-Farley D, Ozair S, et al. Generative Adversarial Networks,  2014. Available: <a href="http://arxiv.org/abs/1406.2661">http://arxiv.org/abs/1406.2661</a> <a href="#fnref39" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn40" class="footnote-item"><p>Goodfellow I. NIPS 2016 Tutorial: Generative Adversarial Networks, 2016. Available: <a href="http://arxiv.org/abs/1701.00160">http://arxiv.org/abs/1701.00160</a> <a href="#fnref40" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn41" class="footnote-item"><p>Devon Hjelm R, Jacob AP, Che T, Cho K, Bengio Y. Boundary-Seeking Generative Adversarial Networks, 2017. Available: <a href="http://arxiv.org/abs/1702.08431">http://arxiv.org/abs/1702.08431</a> <a href="#fnref41" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>

  </div>


</body>

<script>
// config mermaid init call
// http://knsv.github.io/mermaid/#configuration
//
// You can edit the 'MERMAID_CONFIG' variable below.
MERMAID_CONFIG = {
startOnLoad: false
}

if (window['MERMAID_CONFIG']) {
window['MERMAID_CONFIG'].startOnLoad = false
window['MERMAID_CONFIG'].cloneCssStyles = false
}
mermaidAPI.initialize(window['MERMAID_CONFIG'] || {})

if (typeof(window['Reveal']) !== 'undefined') {
function mermaidRevealHelper(event) {
var currentSlide = event.currentSlide
var diagrams = currentSlide.querySelectorAll('.mermaid')
for (var i = 0; i < diagrams.length; i++) {
  var diagram = diagrams[i]
  if (!diagram.hasAttribute('data-processed')) {
    mermaid.init(null, diagram, ()=> {
      Reveal.slide(event.indexh, event.indexv)
    })
  }
}
}

Reveal.addEventListener('slidechanged', mermaidRevealHelper)
Reveal.addEventListener('ready', mermaidRevealHelper)
} else {
mermaid.init(null, document.getElementsByClassName('mermaid'))
}
</script>
